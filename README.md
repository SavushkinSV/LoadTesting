# Нагрузочное тестирование

## Вопросы

1. [Основы тестирования](#основы-тестирования) \
   1.1 [Требования](#требования) \
   1.2 [Дефекты](#дефекты) \
   1.3 [Виды тестирования](#виды-тестирования)
2. [Методика нагрузочного тестирования](#методика-нагрузочного-тестирования) \
  2.1 [Назначение, почему это важно](#назначение-почему-это-важно) \
  2.2 [Основные разделы](#основные-разделы)
3. [Введение в методологию нагрузочного тестирования](#введение-в-методологию-нагрузочного-тестирования) \
  3.1 [Типовой план работ по нагрузочному тестированию](#типовой-план-работ-по-нагрузочному-тестированию) \
  3.2 [Цели НТ](#цели-нт) \
  3.3 [Виды НТ](#виды-нагрузочного-тестирования) \
  3.4 [Поиск максимальной производительности](#поиск-максимальной-производительности) \
  3.5 [Тестирование стабильности](#тестирование-стабильности) \
  3.6 [Стресс тест](#стресс-тест) \
  3.7 [Тестирование стрессоустойчивости](#тестирование-стрессоустойчивости) \
  3.8 [Тестирование отказоустойчивости](#тестирование-отказоустойчивости) \
  3.9 [Объемное тестирование](#объемное-тестирование) \
  3.10  [Тестирование масштабируемости](#тестирование-масштабируемости)
4. [Service Level Agreement](#service-level-agreement)
5. [Профиль нагрузочного тестирования](#профиль-нагрузочного-тестирования) \
  5.1 [Расчет профиля](#расчет-профиля-нагрузочного-тестирования) \
  5.2 [Точность профиля](#точность-профиля) \
  5.3 [Случай с несколькими профилями (например, дневной и ночной)](#случай-с-несколькими-профилями-например-дневной-и-ночной)
6. [Анализ архитектуры систем](#анализ-архитектуры-систем) \
  6.1 [Промышленный и тестовый стенды](#промышленный-и-тестовый-стенды) \
  6.2 Важность их сравнения \
  6.3 [Источники нагрузки](#источники-нагрузки) \
  6.4 [Смежные системы](#смежные-системы) \
  6.4 [Заглушки](#заглушки) \
  6.5 [Протоколы сетевые](#протоколы-сетевые) \
    6.5.1 [Стек (TCP/IP)](#стек-tcpip) \
    6.5.2 [НТТР. Состав запроса и ответа, основные методы, коды ответа](#http-состав-запроса-и-ответа-основные-методы-коды-ответа) \
    6.5.3 [Стандарты обмена REST и SOAP](#) \
  6.6 [Двухзвенная и трехзвенная архитектура](#двухзвенная-и-трехзвенная-архитектура) \
    6.6.1 [Толстый и тонкий клиенты](#толстый-и-тонкий-клиенты) \
    6.6.2 [Основные компоненты тестируемых систем](#основные-компоненты-тестируемых-систем) \
    6.6.3 [Микросервисная и монолитная архитектура](#микросервисная-и-монолитная-архитектура) \
    6.6.4 [Балансировщики нагрузки](#балансировщик-нагрузки) \
    6.6.5 [Брокеры сообщений](#брокеры-сообщений)
7. [JMeter](#jmeter) \
  7.1. [Разработка скриптов](#разработка-скриптов) \
    - Параметризация
    - Корреляция
    - Верификация
    - Настройка pacing
  7.2 Выполнение тестов
    - Создание теста по профилю из МНТ
    - Интеграция c InfluxDB+Grafana
    - Распределенный запуск теста
  7.3 Разбор результатов тестов
    - Основные графики
    - Порядок разбора результатов
  7.4 [Основные элементы](#основные-элементы)
8. [Обзор средств мониторинга](#обзор-средств-мониторинга)
9. [Метрики, собираемые во время нагрузочного тестирования (классификация и примеры наиболее важных)](#метрики-собираемые-во-время-нагрузочного-тестирования)
10. [Базы данных](#базы-данных) \
  10.1 [Введение в БД (классификация и примеры)](#введение-в-бд-классификация-и-примеры) \
  10.2 [Терминология и нормальные формы](#терминология-и-нормальные-формы)
    - [SQL (DDL, DML, DCL, TCL)](#sql-ddl-dml-dcl-tcl)
    - [Select, Update, Insert, Trancate, Delete](#select-update-insert-trancate-delete)
    - [Индексы (плюсы и минусы)](#индексы-плюсы-и-минусы)
    - [View vs Table](#view-vs-table)
    - [Алиасы](#алиасы)
    - [Oracle, AWR](#oracle-awr)
    - [PostgreSQL, аналоги AWR](#postgresql-аналоги-awr)
    - [План запроса (как построить и зачем)](#план-запроса-как-построить-и-зачем)
11. [Введение в заглушки](#)
    - Определение и назначение
    - Плюсы и минусы использования
    - Обзор инструментов и фрейворков
12. [Создание отчетов НТ](#)
13. [Основы программирования](#основы-программирования)
    - [Парадигмы ООП](#парадигмы-ооп)
    - [Классы и объекты](#классы-и-объекты)
14. [Garbage Collection и JVM](#garbage-collection-и-jvm)
15. Самопредставление
  О себе
  О выполненных в рамках школы работах

## Основы тестирования

### Требования

__Требования__ — это конкретные условия и параметры, которым должен соответствовать программный продукт или система. Они определяют, что именно нужно протестировать, чтобы убедиться в качестве продукта.

Требования могут быть функциональными (связанными с определёнными функциями системы) и нефункциональными (касающимися производительности, безопасности, удобства использования и т. д.).

Тестирование требований позволяет проверить соответствие программного продукта установленным критериям и стандартам, а также выявить возможные проблемы и недочёты на ранних этапах разработки. Это помогает обеспечить высокое качество продукта и его успешное внедрение на рынок.

### Дефекты

__Дефект, баг__ - несовершенство или недостаток в рабочем продукте, если он не соответствует требованиям или спецификациям.

__Баг-репорт__ - это документ, описывающий ситуацию или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.

Существует несколько вариантов градации дефектов. Одним из ключевых - по степени влияния на функционал системы:

- S1 блокирующий (blocked)
- S2 критический (critical)
- S3 значительный (major)
- S4 незначительный (minor)
- S5 тривиальный (trivial)

По приоритеру:

- P1 высокий (high)
- P2 средний (medium)
- P3 низкий  (low)

### Виды тестирования

Тестирование программного обеспечения можно классифицировать по различным критериям.

![Классификация тестирования](/images/image_01.jpeg)

Основные виды тестирования:

__Функциональное__ — вид тестирования, при котором проверяются функциональные требования ПО, то есть способность ПО решать возложенные на него задачи. Направлено на проверку корректности работы функциональности приложения. Например, в приложении интернет‑магазина при нажатии на кнопку "Добавить в корзину", товар добавляется в корзину пользователя.

__Автоматизированое__ — тип тестирования, при котором проверки выполняются с использованием программных средств для выполнения тестовых сценариев.
Например, тестировщик пишет код на JavaScript для автоматизации процесса авторизации на сайте.

__Нагрузочное тестирование__ - это проверка устойчивости и производительности программного обеспечения под нагрузкой, сопоставимой с реальными условиями использования.

[Дополнительная информация](https://habr.com/ru/articles/770600/)

[Вопросы](#вопросы)

## Методика нагрузочного тестирования

Перед тем как приступить к проверке программного продукта, нужно разработать __методику нагрузочного тестирования (МНТ)__. Это документ, в котором описан весь план тестирования, включая сценарии возможного развития проекта. МНТ полезна как заказчикам, так и команде исполнителей, потому что позволяет формализовать требования, однозначно определить ожидания от проекта.

### Назначение, почему это важно

Для заказчика - фиксирование всех договоренностей с исполнителем, чтобы он понимал, что получит на выходе.
Для специалистов НТ - МНТ является некоторой "страховкой" при общении с заказчиком. Также МНТ - это инструкция, содержащая информацию по распределению работ. Помогает с передачей знаний по проекту.

### Основные разделы

Основные разделы методики нагрузочного тестирования:

Сокращения и терминология – общий список, встречающийся по тексту. \
Введение – общие слова о проведении НТ. \
__Цели тестирования__ – цели НТ, которые определяют виды тестов. \
__Ограничения и риски__ –  обязательно указываем существующие ограничения и возможные риски. \
__Объект тестирования__ – данные раздела берутся из ТЗ на тестируемую систему. \
__Тестовый стенд__ – схема с описанием тестового стенда, смежных систем, элементов для записи скриптов, моделирования нагрузки и мониторинга. Так же приводится сравнение тестового и промышленного стендов. \
__Планируемые тесты__ – список панируемых тестов с детализацией способов их проведения. \
__Моделирование нагрузки__ – инструменты НТ, профиль нагрузки, сценарии и заглушки. \
Наполнение БД – при необходимости указывается, до каких объемов необходимо наполнить БД. \
Мониторинг – указывается перечень используемых средств мониторинга и список собираемых метрик.

[Вопросы](#вопросы)

## Введение в методологию нагрузочного тестирования

__Нагрузка__ — это количество запросов или операций, которые выполняются на систему за определённый период времени. Нагрузка может быть постоянной или переменной, а также может изменяться в зависимости от времени суток, дня недели и других факторов.

Виды нагрузки:

- __Статическая нагрузка__ — заранее определённое количество запросов, которое выполняется на систему. Статическая нагрузка используется для проверки стабильности системы при определённой нагрузке.
- __Динамическая нагрузка__ — нагрузка, которая изменяется во время тестирования. Динамическая нагрузка позволяет проверить производительность системы при различных условиях.

__Производительность__ — это способность системы выполнять задачи за определённое время. Производительность измеряется в количестве запросов в секунду (QPS), времени отклика (response time) и других показателях.

__Деградация показателей__ — это ухудшение ключевых метрик производительности системы.

### Типовой план работ по нагрузочному тестированию

На следующем рисунке отображен полный цикл нагрузочного тестирования.

![Полный цикл нагрузочного тестирования](/images/image_01_1.png)

Ниже изображен процесс нагрузочного тестирования по релизам.

![Процесс нагрузочного тестирования по релизам](/images/image_01_2.png)

### Цели НТ

Основная цель __нагрузочного тестирования__ - проверка системы на соответствие нефункциональным требованиям.

Основными целямя являются:

- определение максимальной производительности;
- выявление "узких мест";
- проверка стабильности;
- проверка отказоустойчивости;
- проверка стрессоустойчивости;
- проверка системы при стрессовых ситуациях;
- оценка влияния мониторинга;
- проверка масштабирования;
- оценка влияния объемов;
- подборка оптимального комплекса технических средств (КТС);
- проверка исправления ошибок.

Каждую цель необходимо конкретизировать до технических требований. Критерии успеха.

### Виды нагрузочного тестирования

Существует довольно много видов НТ, при этом у каждого свои цели и специфика. Выбор конкретного вида зависит от требований к системе, а также планируемых условий ее использования:

__Нагрузочное тестирование (Load Testing).__ Проверяет работоспособность системы или сайта при заданной нагрузке. С его помощью можно понять, сможет ли система за определенное время обработать желаемое количество запросов.

__Поиск максимальной производительности.__ По результатам тестирования определяется максимальный уровень производительности, при котором система соответствует требованиям, предъявляемым к ней в части
производительности (по временам отклика, утилизации ресурсов, кол-во ошибок и т.д.).

__Тестирование стабильности (Stability Testing).__ Это проверка работоспособности и надежности системы на протяжении длительного времени.

__Стресс тест.__ Целью теста является проверка поведения системы при разных не прогнозируемых условиях. Условия данного теста обговариваются с заказчиком.

__Тестирование стрессоустойчивости (Stress Testing).__ Проводят, чтобы проверить работоспособность системы при огромных нагрузках — больших, чем ожидается в обычных условиях.

__Тестирование отказоустойчивости (Failover Testing).__ Проверка работоспособности системы при аварийных ситуациях. Например, чтобы узнать, переключилась ли система на резервный сервер, если сбой все-таки случился.

__Тестирование объемов (Volume Testing).__ Проверка стабильности системы при работе с большим объемом данных. Показывает, насколько меняется производительность при их обработке.

__Тестирование масштабируемости (Scalability Testing).__ Это тестирование стабильной работы системы при ожидаемом увеличении нагрузки, например, при большем количестве пользователей или объеме данных. Целью теста является проверка влияния увеличения ресурсов системы на её производительность.

### Поиск максимальной производительности

По результатам тестирования определяется максимальный уровень производительности, при котором система соответствует требованиям, предъявленным к ней в части произоводительности. Например, время отклика, утилизация ресурсов, количество ошибок и т.д.

Тест состоит из двух этапов:

- ступенчатый тест;
- подтверждение максимума.

На первом этапе. Нагрузка подается ступенчато. Определяется __L0__. Также может быть определена __Lпик__. Предыдущая ступень от __L0__ – предполагаемый максимум __Lmax__.

![Ступенчатый тест](/images/image_02.png)

Высота ступери зависит от требуемой точности. Длина ступени должна выбираться, чтобы обеспечивать минимум 10 значений изменеренных показателей.

__90-й персентиль__ — это значение, ниже которого находится 90% всех измеренных показателей при выполнении нагрузки.

На втором этапе. Нагрузка подается в течение чана на одном уровне предполагаемого __Lmax__, с плавным выходом на него. Во время теста не должно наблюдаться нарушение требований SLA (времен отклика, утечки памяти, утилизация ресурсов или других изменений).

![Подтветждение максимума](/images/image_03.png)

### Тестирование стабильности

По результатам тестирования определяется возможность системы работать длительное время под нагрузкой.
Основная цель - проверка отсутствия деградации при длительной нагрузке (рост времен отклика, утечка памяти, накопление очередей и т.д.). Нагрузка подается примерно на уровне 80% от максимума или на планируемом уровне нагрузки.

![Тестирование стабильности](/images/image_04.png)

Временя проведения теста стабильности:

- посменно. Время теста равняется время смены плюс один час;
- 24/4 Выбирается от 24 до 72 часов.

### Стресс тест

Целью теста является проверка поведения системы при разных не прогнозируемых условиях. Условия данного теста обговариваются с заказчиком.

Возможные варианты тестов:

- Одновременный переход большого количества пользователей по определённым страницам или какие либо действия, расчёты, покупки и т.д.;
- Одновременная авторизация всех зарегистрированных пользователей в систему;
- Изменение времён отклика смежных систем (ускорение работы смежной системы или наоборот увеличение времени обработки запросов).

### Тестирование стрессоустойчивости

Проводится проверка способности системы к самовосстановлению после стрессовой нагрузки на нее. В частности, определяется, за какое время происходит это восстановление. Повышается нагрузка по всему профилю нагрузочного тестирования.

![Тестирование стрессоустойчивости](/images/image_05.png)

### Тестирование отказоустойчивости

Проводится оценка влияния сбоев смежных систем или одной из компонент системы на работоспособность тестируемой системы, проверка способности системы восстанавливаться после устранения сбоев в смежной системе (по результатам тестирования предоставляется перечень систем и интерфейсов, сбои в которых критически влияют на работоспособность объекта тестирования).

![Тестирование отказоустойчивости](/images/image_06.png)

### Объемное тестирование

Целью теста является проверка влияния увеличения обрабатываемого объёма данных на производительность системы.

Тест проводится в несколько этапов. Первым этапом является тестирование максимальной производительности на системе до изменений, на втором этапом проводится повторный идентичный тест, но уже после изменений.
Изменения бывают двух типов:

- увеличение объёма хранимых данных (в БД, в файловой системе и т.д)
- увеличение объёма отправляемой информации на сервер

В случае, если внесённые изменения не повлияли на производительность системы, тест прошёл успешно и система не деградирует с ростом объёмов данных.

### Тестирование масштабируемости

Целью теста является проверка влияния увеличения ресурсов системы на её производительность.
Существуют два вида масштабируемости системы: вертикальный и горизонтальный. При вертикальном масштабировании происходит увеличение аппаратных ресурсов системы. При горизонтальном масштабировании увеличивают количество серверов приложений или pod микросервисов.

Тест проводится в несколько этапов. На первом этапе проводится тест поиска максимума на системе в первой конфигурации. Затем проводится серия идентичных тестов на разных вариантах конфигурации. После проведения этих тестов производится сравнение результатов. Если производительность системы увеличивается пропорционально увеличению ресурсов, значит система масштабируема и тест прошёл успешно. Любая система масштабируема до определённого уровня. После достижения этого уровня, рост производительности идёт не пропорционально увеличению ресурсов.

![Тестирование масштабируемости](/images/image_07.png)

## Service Level Agreement

__SLA (Service Level Agreement)__ в тестировании — это соглашение между заказчиком и исполнителем об уровне предоставления услуг, которое определяет параметры качества.

В контексте тестирования SLA устанавливает стандарты и ожидания относительно качества продукта или услуги, а также определяет критерии успешности тестирования. Это помогает обеспечить соответствие продукта требованиям заказчика и стандартам качества.

Основные аспекты SLA в тестировании включают:

Цели и задачи тестирования: определение основных целей и задач тестирования, которые должны быть достигнуты в рамках SLA.
Критерии успешности: установление критериев, по которым будет оцениваться успешность тестирования, таких как количество найденных дефектов, время выполнения тестов и т. д.
Сроки и этапы тестирования: определение сроков и этапов проведения тестирования, чтобы обеспечить своевременное выполнение работ.
Ответственность сторон: распределение ответственности между заказчиком и исполнителем за выполнение условий SLA.

Таким образом, SLA является важным инструментом для обеспечения качества и надёжности продукта или услуги.

В нагрузочном тестировании под SLA понимают требования предъявляемые к системе, что в свою очередь для нас является основными критериями успешности теста. В нагрузочном тестировании SLA могут быть наложены следующием параметры системы:

- время отклика;
- процент ошибок;
- утилизация аппаратных ресурсов;
- время восстаносления системы.

## Профиль нагрузочного тестирования

__Профиль__ – набор операций, выбранных для нагрузочного тестирования, и их интенсивность.

В профиль входят:

- Наиболее интенсивные операции
- Бизнес критичные операции
- Тяжелые операции (ресурсоемкие)

### Расчет профиля нагрузочного тестирования

Расчет может проводиться:

- на основе аналитики;
- на основе статистики.

Последовательность действий при расчете профиля на основе статистики:

- Выбор периода сбора статистики (обычно последний квартал)
- Анализ и отсеивание неподходящих часов
- Выбор часа пиковой нагрузки
- Выбор операций для включения в профиль
- Определение интенсивности операций профиля

### Точность профиля

__Точность профиля__ нагрузочного тестирования — это показатель, который отражает, насколько точно тестовые сценарии и параметры нагрузки соответствуют реальным условиям использования системы или приложения. Точность считается как отношение суммы интенсивностей выбранных операций к сумме интенсивностей всех операций выбранного часа. Точность должна быть более 90% от суммы интенсивносте всех операция выбранного часа.

### Случай с несколькими профилями (например, дневной и ночной)

Дневной профиль используется для имитации типичной дневной нагрузки на систему. Он включает в себя сценарии, которые отражают действия пользователей в течение рабочего дня.

Ночной профиль используется для проверки системы в условиях низкой нагрузки. Он позволяет выявить проблемы, связанные с ночным временем, когда активность пользователей минимальна. Например, можно протестировать систему резервного копирования данных или обновления программного обеспечения.

## Анализ архитектуры систем

__Анализ архитектуры системы__ — это процесс изучения и оценки структуры, компонентов и взаимодействий между ними в рамках определённой системы. Он включает в себя оценку дизайна системы, её компонентов, их взаимосвязей и поведения.

Единственной и самой точной моделью является сам объект тестирования. Для построения тестовой модели используется абстракция. Чем точнее тестовая модель, тем точнее будут результаты тестирования. Тестовая модель может и должна уточняться по ходу тестирования и по мере поступления дополнительных данных.

### Промышленный и тестовый стенды

__Промышленный стенд__ представляет собой среду, которая имитирует реальные условия эксплуатации системы или продукта. Это позволяет разработчикам и инженерам тестировать и отлаживать систему в условиях, максимально приближенных к реальным. Промышленный стенд может включать в себя аппаратное и программное обеспечение, а также другие компоненты, которые используются в производственной среде.

__Тестовый стенд__ предназначен для тестирования и отладки новых функций, изменений в системе или исправления ошибок. Тестовый стенд обычно имеет более контролируемую среду, что позволяет разработчикам изолировать определённые аспекты системы и тщательно протестировать их.

Оба типа стендов играют важную роль в процессе разработки и эксплуатации систем. Они помогают обеспечить качество и надёжность продуктов, а также позволяют разработчикам быстро и эффективно вносить изменения и улучшения.

### Источники нагрузки

Источники нагрузки делятся на два типа:

- видимые (пользователи, внешние системы);
- невидимые (фоновые процессы).

### Смежные системы

В нагрузочном тестировании __смежные системы__ — это системы, которые взаимодействуют с основной системой, подвергающейся нагрузке. Они играют важную роль в обеспечении точности и достоверности результатов тестирования.

Смежные системы включают:

- Базы данных. Системы, используемые для хранения и обработки данных. Нагрузочное тестирование должно учитывать нагрузку на базы данных, чтобы оценить их производительность и стабильность.
- API и веб-сервисы. Программные интерфейсы, через которые происходит обмен данными между системами. Тестирование API и веб-сервисов помогает выявить узкие места и проблемы с производительностью.
- Очереди сообщений. Системы обмена сообщениями, такие как RabbitMQ или Kafka. Нагрузочное тестирование очередей сообщений позволяет оценить их способность обрабатывать большое количество сообщений.
- Системы кэширования. Системы хранения данных в оперативной памяти для ускорения доступа к ним. Тестирование систем кэширования помогает определить их эффективность и влияние на производительность основной системы.
- Другие системы интеграции. Любые другие системы, с которыми основная система обменивается данными. Это могут быть системы электронной почты, платёжные системы и т. д.

### Заглушки

__Заглушки__ в нагрузочном тестировании — это специальные программные компоненты, которые используются для имитации ответов от внешних систем во время тестирования. Они позволяют разработчикам и тестировщикам создавать тестовые сценарии без необходимости подключения к реальным внешним сервисам.

Необходимость в заглушках может возникнуть в следующих случаях:

- смежные системы являются потенциально узким местом с точки зрения производительности;
- смежные системы не доступны на тестовом стенде;
- смежные системы еще не разработаны или находятся в постоянной доработке;
- есть необходимость проверить тестируемую системы при различных временах отклика смежных систем.

Заглушки помогают ускорить процесс тестирования, так как они предоставляют заранее определённые ответы на запросы, что позволяет сосредоточиться на функциональности тестируемого приложения. Это особенно полезно при проведении нагрузочного тестирования, когда необходимо проверить работу системы под высокой нагрузкой.

Для написания заглушки необходимо знать:

- тела запроса;
- тело ответа;
- время отклика;
- производительность;
- протокол передачи данных.

Основные преимущества использования заглушек в нагрузочном тестировании:

- Изоляция тестируемой системы. Заглушки позволяют изолировать тестируемую систему от внешних зависимостей, что упрощает процесс тестирования и позволяет сосредоточиться на конкретных функциях.
- Ускорение тестирования. Заглушки предоставляют быстрые и предсказуемые ответы, что ускоряет процесс тестирования.
- Контроль над тестовыми данными. Заглушки позволяют контролировать тестовые данные, что обеспечивает стабильность и повторяемость тестов.
- Упрощение отладки. Заглушки могут помочь упростить отладку, предоставляя контролируемые ответы на запросы.

Однако использование заглушек также имеет некоторые недостатки:

- Сложность создания и поддержки. Создание и поддержка заглушек может быть сложным и трудоёмким процессом.
- Риск ошибок. Неправильно настроенные заглушки могут привести к ошибкам в тестах.
- Ограниченная функциональность. Заглушки не всегда могут полностью заменить реальные внешние сервисы, что может ограничить тестирование некоторых функций.

## JMeter

Apache JMeter — это инструмент для нагрузочного тестирования, который позволяет моделировать различные сценарии нагрузки на веб-приложения и другие сервисы. Он поддерживает как параметризацию, так и корреляцию, что делает его идеальным выбором для создания реалистичных тестов.

### Разработка скриптов

__Скрипт (от англ. «script»)__ — это набор команд или инструкций, которые используются для автоматизации определённых задач или процессов. Скрипты могут быть написаны на различных языках программирования и использоваться в разных областях, таких как веб-разработка, автоматизация тестирования, управление задачами и т. д.

В автоматизации тестирования скрипты помогают автоматизировать процесс тестирования программного обеспечения, выполняя повторяющиеся задачи и проверяя результаты.

__Параметризация__ — это процесс, при котором тестовые сценарии настраиваются с использованием различных входных данных или параметров для имитации реальных условий работы системы. Параметризация позволяет автоматизировать процесс тестирования, делая его более эффективным и менее подверженным ошибкам.

__Корреляция__ — это процесс, при котором значения, полученные в ходе тестирования, используются для создания более реалистичных сценариев, отражающих взаимодействие между различными компонентами системы. Это особенно важно, когда тестируемое приложение зависит от динамически генерируемых данных, таких как сессии, токены или идентификаторы. Корреляция также называется динамической параметризацией данных.

__Верификация__ — это процесс проверки и подтверждения, что тестовые сценарии и инструменты соответствуют требованиям и целям тестирования. Это ключевой этап, который обеспечивает точность и надёжность результатов тестирования.

__Pacing__ — интервал времени в течение которого гарантировано выполняется один проход сценария. Состоить из времени выполнения сценария и паузы до запуска следующего сценария. Pacing необходим для поддержании заданной интенсивности работы теста.

Расчитывается pacing по формуле `p = 3600 * Пользователи / Интенсивность`.

### Основные элементы

__Группа потоков (Thread Group)__ – основной рабочий элемент, в который записываются сценарии, добавляется различная логика и элементы управления, участвующие в тесте.

__Элементы конфигурации (Configuration Elements)__ позволяют задавать глобальные настройки для всего тестового плана, а также объявлять переменные, данные из которых впоследствии уже будут использованы сэмплерами.
К числу наиболее важных элементов относятся следующие:

- CSV Data Set Config;
- HTTP Request Defaults;
- User Defined Variables;
- HTTP Header Manager;
- JDBC Connection Configuration;
- HTTP Cache Manager;
- HTTP Cookie Manager;
- FTP Request Defaults;
- Counter.

__Сэмплеры (Samplers)__ используются для обращения Jmeter к серверу путем отправки запросов. К числу наиболее важных сэмплеров относятся:

- HTTP Request;
- FTP Request;
- SMTP Sampler;
- JDBC Request;
- Debug Sampler.

__Логический контроллер (Logic Controller)__ позволяет выстроить порядок обработки сэмплеров в тестовом плане. К числу наиболее важных логических контроллеров относятся:

- Loop Controller;
- Random Controller;
- Recording Controller;
- RunTime Controller;
- If Controller;
- While Controller;
- Simple Controller.

__Препроцессоры (Pre-Processor)__ – это элементы Jmeter, которые используются для выполнения действий до выполнения запросов сэмплера в тестовом сценарии. Препроцессоры могут использоваться для различных задач тестирования производительности, таких как выборка данных из базы данных, установка тайм-аута между выполнением сэмплера или перед генерацией тестовых данных.

Среди самых важных препроцессоров можно выделить следующие:

- BeanShell PreProcessor;
- JSR223 PreProcessor;
- JDBC PreProcessor.

__Пост-обработчики (Post-Processors)__ – элементы Jmeter, которые выполняются после завершения сэмплеров и используются, главным образом, для обработки данных ответа сервера и извлечения конкретного значения разметки для его последующего использования в тесте.

Далее перечислены наиболее часто используемые пост-обработчики:

- BeanShell PostProcessor;
- JSR223 PostProcessor;
- JDBC PostProcessor;
- CSS/JQuery Extractor;
- Xpath Extractor;
- Regular Expression Extractor;
- Debug PostProcessor.

__Таймеры (Timers)__ - используется для имитации пользовательского ожидания в Jmeter. К числу наиболее важных таймеров относятся:

- Constant Timer;
- Uniform Random Timer;
- Gaussian Random Timer;
- JSR223 Timer;
- BeanShell Timer.

__Элемент подтверждения (Assertion)__ используются в качестве инструмента проверки (верификации) в Jmeter. К числу наиболее важных элементов подтверждения можно отнести следующие:

- Response Assertion;
- Size Assertion;
- Duration Assertion;
- JSR223 Assertion.

__Листенеры (listeners)__– элементы тестового плана, которые используются для просмотра и анализа информации, собранной JMeter во время прохождения теста, в табличной или графической форме. В них также собраны и сгруппированы различные метрики производительности, с помощью которых могут быть выявлены ограничители производительности системы. Одними из самых востребованных листенеров являются:

- View Results Tree;
- Aggregate Report;
- Aggregate Graph;
- Simple Data Writer;
- Summary Report.

__Transaction Controller__ — транзакция верхнего уровня для замера длительности работы всего сценария и пауз.

__Ultimate Thread Group__ — сторонний эдемент, для задания количества пользователей и длительности их работы, для запуска сценария.

__Module Controller__ — ссылка на сценарий в __Test Fragment__

### Протоколы сетевые

__Модель OSI (Open Systems Interconnection)__ — это эталонная модель, разработанная для описания функций телекоммуникационных или вычислительных систем, необходимых для сетевого взаимодействия. Она разделяет процесс сетевого взаимодействия на семь взаимосвязанных уровней. Каждый уровень выполняет специфические функции и взаимодействует с уровнями непосредственно выше и ниже.

[Дополнительная информация](https://habr.com/ru/articles/820419/)

![Сложно о простом. Модель OSI и TCP/IPы](/images/image_08.png)

__Физический уровень L1 (Physical Layer):__

Функции: определяет электрические, механические, процедурные и функциональные характеристики для активации, поддержания и деактивации физических соединений между конечными системами.

Примеры: кабели, разъемы, электрические напряжения, физические топологии сетей.

Необходимые для этого уровня понятия: RS-232, RJ45, V.34, 100BASE-TX, SDH, DSL, 802.11.

__Канальный уровень L2 (Data Link Layer):__

Функции: обеспечивает надежную передачу данных через физический канал. Включает задачи по обнаружению и исправлению ошибок, а также управление доступом к среде передачи.

Примеры: Ethernet, MAC-адреса, фреймы, коммутаторы.

Необходимые для этого уровня понятия: Ethernet, 802.11, MAC/LLC, VLAN, ATN, HDP, Fibre Channel, FrameReplay, HDLC, PPP, Q.921, Token Ring.

__Сетевой уровень L3 (Network Layer):__

Функции: отвечает за маршрутизацию пакетов данных между узлами сети. Обеспечивает логическую адресацию и определяет пути передачи данных через различные сети.

Примеры: IP-адресация, маршрутизаторы, IP-протокол.

Необходимые для этого уровня понятия: IP, ARP, IPsec, ICMP, IGMP, OSPF.

__Транспортный уровень L4 (Transport Layer):__

Функции: обеспечивает надежную передачу данных, контроль ошибок, сегментацию и повторную сборку данных. Гарантирует, что данные передаются без потерь и дубликатов.

Примеры: TCP (Transmission Control Protocol), UDP (User Datagram Protocol).

Необходимые для этого уровня понятия: TCP, UDP, SCTP, SSL, TLS.

__Сеансовый уровень L5 (Session Layer):__

Функции: управляет сеансами связи между приложениями. Обеспечивает установку, поддержание и завершение сеансов, а также синхронизацию и управление обменом данными.

Примеры: управление сеансами, контроль диалога.

Более подробней в этой статье.

Необходимые для этого уровня понятия: Session establishment in TCP, SIP, RTP, RPC-Named pipes.

__Представительный уровень L6 (Presentation Layer):__

Функции: отвечает за преобразование данных в формат, подходящий для приложения или сети. Включает задачи по шифрованию, дешифрованию, сжатию и преобразованию данных.

Примеры: шифрование, кодирование данных, преобразование форматов.

Необходимые для этого уровня понятия: HTML, DOC, JPEG, MP3, AVI, Sockets.

__Прикладной уровень L7 (Application Layer):__

Функции: обеспечивает доступ приложений к сетевым услугам. Реализует протоколы, которые поддерживают конечные пользовательские процессы и сетевые приложения.

Примеры: HTTP (HyperText Transfer Protocol), FTP (File Transfer Protocol), SMTP (Simple Mail Transfer Protocol).

Необходимые для этого уровня понятия: DNS, WWW, HTTP, P2P, EMAIL, POP, SMTP, TELNET, SSH, FTP, TFTP.

#### Стек (TCP/IP)

#### HTTP. Состав запроса и ответа, основные методы, коды ответа

__Hypertext Transfer Protocol, HTTP (протокол передачи гипертекста)__ — это протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

__Запрос (HTTP Request)__ — это сообщение, которое отправляется клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к какому-либо ресурсу. Основой запроса является HTTP-заголовок.

__Ответ (HTTP Response)__ — это сообщение, которые сервер отправляте в ответ на клиентский запрос.

Каждое HTTP-сообщение состоит из следующих частей, которые передаются в указанном порядке:

- __Стартовая строка (англ. Starting line)__ — определяет тип сообщения. Используется для описания версии используемого протокола и другой информации.
- __Заголовки (англ. Headers)__ — характеризуют тело сообщения, параметры передачи и прочие сведения; после каждой строки следует символ CRLF.
- __Пустая строка__ То есть строка, в которой ничего не предшествует CRLF, она обозначает конец полей заголовка.
- __Тело сообщения (англ. Message Body)__ — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Стартовая строка сообщения

Стартовые строки различаются для запроса и ответа.

Стартовая строка ответа сервера имеет следующий формат:

HTTP/Версия КодСостояния Пояснение

где:

- __Версия__ — пара разделённых точкой цифр, как в запросе;
- __Код состояния (англ. Status Code)__ — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;
- __Пояснение (англ. Reason Phrase)__ — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.

 Поля заголовка

Поля HTTP заголовка предоставляют необходимую информацию о запросе или ответе или об объекте, отправленном в теле сообщения. Существует четыре типа заголовков HTTP-сообщений:

- General (Общие заголовки): эти поля заголовка имеют общее применение как для сообщений запроса, так и для сообщений ответа.
- Request (Заголовки запроса): эти поля заголовка применимы только для сообщений запроса.
- Response (Заголовки ответа): эти поля заголовка применимы только для ответных сообщений.
- Entity (Заголовки сущности): эти поля заголовка определяют метаинформацию о теле объекта

Все вышеупомянутые заголовки следуют одному и тому же общему формату, и каждое поле заголовка состоит из имени, за которым следует двоеточие (:) и значение поля, как показано ниже:

имя-поля: [значение-поля]

Ниже приведены примеры различных полей заголовка:

```text
Host: suip.biz
User-Agent: Chrome
Accept: */*

Date: Tue, 03 Nov 2020 06:15:50 GMT`
Server: Apache/2.4.46 (Unix) PHP/7.4.12
Vary: Accept-Encoding
X-Powered-By: PHP/7.4.12
X-Frame-Options: SAMEORIGIN
Content-Type: text/html; charset=UTF-8
X-Varnish: 328517
Age: 0
Via: 1.1 varnish (Varnish/6.5)
Accept-Ranges: bytes
Connection: keep-alive
```

Тело сообщения

Часть сообщения, которое называется телом, является необязательной для HTTP-сообщения, но если она доступна, она используется для переноса тела объекта, связанного с запросом или ответом. Если тело объекта присутствует, то обычно строки заголовков Content-Type и Content-Length указывают природу тела сообщения.

Тело сообщения — это та часть, которая содержит фактические данные HTTP-запроса (сюда же относятся данные, передаваемые через веб-формы и выгружаемые файлы) и данные HTTP-ответа от сервера (включая HTML код, файлы, изображения и т. д.). Ниже приводится простое содержание тела сообщения (ответ):

```text
<html>
<body>
<h1>Hello, World!</h1>
</body>
</html>
```

Метод запроса

__Метод HTTP (англ. HTTP Method)__ — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.

__Идемпотентные вызовы__ — это операции или запросы, которые можно повторять многократно, не изменяя результат после первого выполнения. Другими словами, повторный идемпотентный вызов не приводит к новым изменениям состояния системы или данных, если они уже были успешно обработаны (GET, HEAD, PUT, DELETE, OPTIONS, TRACE).

__Неидемпотентные вызовы__ — это операции или запросы, при повторном выполнении которых результат может измениться или побочные эффекты могут отличаться от первоначального вызова (POST, PUT, DELETE, PATCH).

| Метод   | Описание |
|---------|----------|
| GET     |  Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: `GET /path/resource?param1=value1&param2=value2 HTTP/1.1` Согласно стандарту HTTP, запросы типа GET считаются идемпотентными |
| HEAD    | Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. |
| POST    |  Применяется для передачи пользовательских данных заданному ресурсу, в том числе выгрузки файлов на веб-сервер. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер. В отличие от метода GET, метод POST не считается идемпотентным, то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария). |
| PUT     | Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented). |
| DELETE  | Удаляет указанный ресурс. |
| CONNECT | Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси. |
| OPTIONS | Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях. |
| TRACE   | Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе. |
| PATCH   | Аналогично PUT, но применяется только к фрагменту ресурса. |

Ответы

После получения и интерпретации сообщения запроса сервер отвечает сообщением ответа HTTP, его структура:

- Строка состояния
- Ноль или более полей заголовка (общие заголовки, заголовки ответа и заголовки сущности), за которыми следует символ CRLF
- Пустая строка (т.е. строка, в которой ничего не предшествует CRLF), указывающая на конец полей заголовка
- Необязательно тело сообщения

Код состояния

Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.

В настоящее время выделено пять классов кодов состояния.

| Код | Класс           | Назначение |
|-----|-----------------|------------|
| 1xx | Информационный  | Информирование о процессе передачи. Носят исключительно информативный характер и никак не влияют на обработку запроса. |
| 2xx | Успех           | Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения. |
| 3xx | Перенаправление | Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI. |
| 4xx | Ошибка клиента  | Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя. |
| 5xx | Ошибка сервера  | Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю. |

### Двухзвенная и трехзвенная архитектура

__Двузвенная (двухуровневая) архитектура__ программного обеспечения состоит из двух основных компонентов: клиентского приложения и сервера. Клиентское приложение отвечает за пользовательский интерфейс и обработку данных на стороне пользователя, а сервер обеспечивает хранение данных и выполнение бизнес-логики.

__Трёхзвенная (трёхуровневая) архитектура__ представляет собой более сложную структуру, состоящую из трёх основных компонентов: клиента, сервера приложений и сервера баз данных. Клиент отвечает за пользовательский интерфейс, сервер приложений обрабатывает запросы от клиента и взаимодействует с сервером баз данных, который хранит данные и выполняет операции с ними.

### Толстый и тонкий клиенты

__Толстый клиент__ — это компьютер или программа, которая выполняет большую часть работы по обработке данных и имеет достаточно ресурсов для выполнения сложных задач. Толстые клиенты обычно имеют большой объём памяти, мощный процессор и могут работать с различными приложениями. Они также могут хранить данные локально и обрабатывать их без необходимости обращения к центральному серверу.

Примеры толстых клиентов: настольные приложения, такие как Microsoft Office или Adobe Photoshop,     игровые приставки, которые могут выполнять сложные вычисления и запускать игры без подключения к интернету.

__Тонкий клиент__ — это устройство или программа, которое выполняет ограниченные функции и зависит от центрального сервера для обработки данных. Тонкие клиенты обычно не имеют мощных процессоров или большого объёма памяти и полагаются на сервер для выполнения задач. Они могут быть простыми в использовании и не требовать сложных настроек.

Примеры тонких клиентов: веб-браузеры, терминалы для доступа к удалённым рабочим столам, некоторые мобильные приложения, которые используют облачные технологии для хранения данных и обработки запросов.

### Основные компоненты тестируемых систем

![Основные компоненты тестируемых систем](/images/image_09.png)

### Микросервисная и монолитная архитектура

__Монолитная архитектура__ — это подход к разработке программного обеспечения, при котором все компоненты приложения интегрированы в единый исполняемый файл или модуль. В такой архитектуре все функции и модули тесно связаны между собой и работают как единое целое. Это упрощает разработку, тестирование и развёртывание на начальных этапах, но может стать проблемой при масштабировании и внесении изменений в будущем.

__Микросервисная архитектура__ — это подход, при котором приложение разбивается на небольшие независимые сервисы, каждый из которых выполняет определённую функцию и может быть развёрнут и масштабирован отдельно от других. Микросервисы взаимодействуют друг с другом через чётко определённые API, что позволяет разработчикам работать над каждым сервисом независимо, а также упрощает внесение изменений и масштабирование отдельных компонентов приложения.

Монолиты полезно использовать на начальных этапах проектов, чтобы облегчить развертывание и не тратить слишком много умственных усилий на управление кодом. Когда монолитное приложение становится большим и сложным, возникают трудности с его масштабированием и непрерывным развертыванием, а обновление становится неудобным.

Монолитное приложение создается как единое и неделимое целое, тогда как в микросервисной архитектуре его разбивают на множество независимых модулей, каждый из которых вносит свой вклад в общее дело. Приложение создают как набор независимо развертываемых сервисов, которые являются децентрализованными и разрабатываются независимо друг от друга.

### Балансировщик нагрузки

__Балансировщик нагрузки__ – это устройство, которое находится между пользователем и группой серверов и действует как невидимый посредник, обеспечивая одинаковое использование всех серверов и ресурсов.
Балансировка нагрузки направляет и контролирует интернет-трафик между серверами приложений и их посетителями или клиентами. В результате повышается доступность, масштабируемость, безопасность и производительность приложения.

__Статическая балансировка нагрузки__
Алгоритмы статической балансировки нагрузки следуют фиксированным правилам и не зависят от текущего состояния сервера.

- Метод круговой системы
- Взвешенный циклический метод
- Метод хеширования IP

__Динамическая балансировка нагрузки__
Алгоритмы динамической балансировки нагрузки проверяют текущее состояние серверов перед распределением трафика.

- Метод наименьшего подключения
- Метод наименьшего количества подключений.
- Метод наименьшего времени отклика
- Метод на основе ресурсов

### Брокеры сообщений

__Брокер сообщений__ представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника.

В работе любого брокера сообщений используются две основные сущности: __producer (поставщик сообщений)__ и __consumer (потребитель/подписчик)__.
Одна сущность занимается созданием сообщений и отправкой их другой сущности-потребителю. В процессе отправки есть ещё серединная точка, которая представляет собой папку файловой системы, где хранятся сообщения, полученные от продюсера.
Брокеры сообщений реализуют механизм асинхронного обмена данными.

__RabbitMQ__ - представляет собой классический брокер, в котором присутствуют две сущности – продюсер (система, генерирующая сообщения о разнообразных событиях) и подписчик, являющийся получателем этих сообщений.
Обе эти сущности в процессе работы взаимодействуют с очередью сообщений, которая представляет собой хранилище, где накапливаются отправляемые сообщения.
В рамках этого брокера инициатором информационного обмена является продюсер, только он отправляет сообщение в сеть, в то время как подписчик не может запросить его сам («push-доставка сообщений»).

__Apache Kafka__ представляет собой брокер, который, в отличие от RabbitMQ, хранит все сообщения в виде распределённого лога, причём гарантируется, что порядок сообщений отражает последовательность их поступления в систему. Сообщение в этом логе хранится в течение определённого времени, и работа построена таким образом, что продюсеры пишут новые сообщения в систему, а подписчики сами их запрашивают. По сути Kafka представляет из себя log-транзакции.

### Обзор средств мониторинга

Prometheus+Grafana

__Prometheus__ — это система мониторинга и оповещения с открытым исходным кодом, предназначенная для сбора и хранения метрик в виде временных рядов. Она позволяет отслеживать различные показатели производительности и состояния систем, сервисов и приложений. Является сборщиком и хранилищеи данных.

__Grafana__ — это инструмент с открытым исходным кодом для мониторинга и анализа данных в реальном времени. Он предоставляет возможность создания интерактивных дашбордов, визуализации метрик и работы с различными источниками данных, такими как базы данных временных рядов, логи и другие. Является инструментом отрисовки данных.

Telegraf+InfluxDB+Grafana

__Telegraf__ — это агент для сбора метрик и событий, который собирает, структурирует и отправляет данные на серверы для дальнейшей обработки и анализа. Он может собирать данные из различных источников, таких как системы мониторинга, логи, базы данных и другие, и отправлять их в различные системы хранения данных, такие как InfluxDB, Graphite, Prometheus и другие. Является сборщиком данных.

__InfluxDB__ — это база данных типа «ключ-значение» с открытым исходным кодом, специально разработанная для работы с временными рядами данных. Она используется для хранения и анализа данных, которые меняются во времени, таких как метрики, логи, события и другие типы данных, генерируемых в реальном времени. Является хранилищем данных.

### Метрики, собираемые во время нагрузочного тестирования

__Метрики__ — это количественные показатели, которые используются для оценки производительности и стабильности системы при различных уровнях нагрузки. Они помогают определить, как система справляется с нагрузкой, и выявить потенциальные проблемы.

#### Бизнес-метрики

__Бизнес-метрики__ — это показатели, которые помогают оценить, как система справляется с нагрузкой и насколько эффективно она работает в условиях реального использования. Они позволяют понять, насколько хорошо система соответствует бизнес-целям и требованиям пользователей.

__Пропускная способность (Throughput)__ — количество запросов, которые система может обработать за определённый период времени. Измеряется в запросах в секунду или транзакциях в минуту.

__Время отклика (Response Time)__ — время, которое требуется системе для обработки запроса пользователя. Измеряется от момента отправки запроса до получения ответа.

__Коэффициент ошибок (Error Rate)__ — процент запросов, которые не были обработаны успешно. Помогает выявить проблемы с производительностью или стабильностью системы.

__Количество одновременно обрабатываемых пользователей (Concurrent Users)__ — максимальное количество пользователей, которые могут одновременно работать с системой без потери производительности.

#### Аппаратные метрики

__Использование ресурсов (Resource Utilization)__ — показатели использования CPU, памяти, дискового пространства и других ресурсов системы при различных нагрузках.

Процессор (CPU):

- __Утилизация CPU (CPU utilization)__ — это показатель, который отражает степень использования процессорного времени.
- __Время простоя (idle time)__ — это время, в течение которого CPU не выполняет никаких задач.
- __Длина очереди к CPU (Processor Queue Length)__ — это количество задач, ожидающих обработки процессором.
- __Интенсивность контектсных переключений__ — это частота, с которой процессор переключается между различными задачами или потоками.

Оперативная память (memory):

- Объем/процент свободной памяти
- Объем/частота использования файла подкачки (Swap)

__Объём свободной памяти__ — это количество неиспользуемой в данный момент оперативной памяти. Он измеряется в байтах (чаще всего в гигабайтах). Чем больше свободной памяти, тем больше ресурсов доступно для запуска и работы программ.

__Процент свободной памяти__ — это отношение объёма свободной памяти к общему объёму оперативной памяти, выраженное в процентах. Этот показатель позволяет оценить, насколько эффективно используется оперативная память.

__Объём файла подкачки__ — это размер этого файла, который может быть задан пользователем или автоматически определён системой.

__Частота использования файла подкачки__ — это показатель того, как часто система обращается к файлу подкачки для обмена данными с оперативной памятью.

Диск (disk):

- Скорость операций чтения/записи
- Длина очереди диска
- Свободное место на диске и/или в конкретных директориях

Сеть (NET):

- Скорость передачи данных
- Задержка сети
- Потеря пакетов
- Очередь пакетов

#### Программные метрики

- заглушки
- базы данных
- сервера приложений
- веб-серверы
- интешрационные решения

Заглушка, написанная на Java.

Основные метрики:

- Threads count – количество потоков
- Free memory – свободный объем heap
- GC – работа сборщика мусора

Сервер приложения и веб-сервера, выполняющие код на Java

Основные метрики:

- Threads count – количество потоков
- Free memory – свободный объем heap
- HTTP Requests – количество запросов
- Sessions count – количество активных сессий

В случае микросервисной архитектуры:

- Threads count – количество потоков
- Free memory – свободный объем heap
- HTTP Requests – количество запросов
- Sessions count – количество активных сессий

Базы данных

Основные online-метрики:

- Количество сессий в различных статусах (active, inactive, wait…)
- Количество блокировок

На стороне App:
Количество connection pool

Основные offline-метрики:

- рейтинг запросов по времени ответа
- рейтинг запросов по утилизации ресурсов
- прочие, которые рассматриваются в теме про СУБД

[Вопросы](#вопросы)

### Базы данных

#### Введение в БД (классификация и примеры)

#### Терминология и нормальные формы

#### SQL (DDL, DML, DCL, TCL)

#### Select, Update, Insert, Trancate, Delete

#### Индексы (плюсы и минусы)

#### View vs Table

#### Алиасы

#### Oracle, AWR

#### PostgreSQL, аналоги AWR

#### План запроса (как построить и зачем)

### Основы программирования

#### Парадигмы ООП

__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

- объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
- каждый объект является экземпляром определенного класса;
- классы образуют иерархии.

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.

Оосновные принципы _ООП_:

- _Инкапсуляция_ - сокрытие реализации
- _Наследование_ - создание новой сущности на базе уже существующей
- _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности
- _Абстракция_ - набор общих характеристик
  
__Инкапсуляция__ – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется _предком_, _базовым_ или _родительским_. Новый класс – _потомком_, _наследником_ или _производным_ классом.

__Полиморфизм__ – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

Полиморфизм бывает _динамическим_ (переопределение) и _статическим_ (перегрузка).

_Полиморфная переменная_, это переменная, которая может принимать значения разных типов, а _полиморфная функция_, это функция у которой хотя бы один аргумент является полиморфной переменной.
Выделяют два вида полиморфных функций:

- _ad hoc_, функция ведет себя по разному для разных типов аргументов (например, функция `draw()` — рисует по разному фигуры разных типов);
- _параметрический_, функция ведет себя одинаково для аргументов разных типов (например, функция `add()` — одинаково кладет в контейнер элементы разных типов).

_Абстрагирование_ – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, __абстракция__ – это набор всех таких характеристик.

#### Классы и объекты

Класс — это тип данных, созданный пользователем. Он содержит разные свойства и методы, как, например, тип String или Integer. Класс — это «шаблон» для объекта, который описывает его свойства. Несколько похожих между собой объектов, например профили разных пользователей, будут иметь одинаковую структуру, а значит, принадлежать к одному классу.

Объект — это основная единица в ООП, представляющая собой экземпляр класса, сочетающий в себе данные (состояние) и методы (поведение) для работы с этими данными. Например, когда вы создаёте переменную типа String и присваиваете ей значение «Строка», то в памяти создаётся экземпляр класса String.

[Вопросы](#вопросы)

## Garbage Collection и JVM

[Дюк, вынеси мусор! — 1. Введение](https://habr.com/ru/articles/269621/) \
[Дюк, вынеси мусор! — 2. Serial GC и Parallel GC](https://habr.com/ru/articles/269707/) \
[Дюк, вынеси мусор! — 3. CMS и G1](https://habr.com/ru/articles/269863/)

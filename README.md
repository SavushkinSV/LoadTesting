# Нагрузочное тестирование

## Вопросы

1. [Основы тестирования](#основы-тестирования) \
   1.1 [Требования](#требования) \
   1.2 [Дефекты](#дефекты) \
   1.3 [Виды тестирования](#виды-тестирования)
2. [Методика нагрузочного тестирования](#методика-нагрузочного-тестирования) \
  2.1 [Назначение, почему это важно](#назначение-почему-это-важно) \
  2.2 [Основные разделы](#основные-разделы)
3. [Введение в методологию нагрузочного тестирования](#введение-в-методологию-нагрузочного-тестирования) \
  3.1 [Типовой план работ по нагрузочному тестированию](#типовой-план-работ-по-нагрузочному-тестированию) \
  3.2 [Цели НТ](#цели-нт) \
  3.3 [Виды НТ](#виды-нагрузочного-тестирования) \
  3.4 [Поиск максимальной производительности](#поиск-максимальной-производительности) \
  3.5 [Тестирование стабильности](#тестирование-стабильности) \
  3.6 [Стресс тест](#стресс-тест) \
  3.7 [Тестирование стрессоустойчивости](#тестирование-стрессоустойчивости) \
  3.8 [Тестирование отказоустойчивости](#тестирование-отказоустойчивости) \
  3.9 [Объемное тестирование](#объемное-тестирование) \
  3.10  [Тестирование масштабируемости](#тестирование-масштабируемости)
4. [Service Level Agreement](#service-level-agreement)
5. [Профиль нагрузочного тестирования](#профиль-нагрузочного-тестирования) \
  5.1 [Расчет профиля](#расчет-профиля-нагрузочного-тестирования) \
  5.2 [Точность профиля](#точность-профиля) \
  5.3 [Случай с несколькими профилями (например, дневной и ночной)](#случай-с-несколькими-профилями-например-дневной-и-ночной)
6. [Анализ архитектуры систем](#анализ-архитектуры-систем) \
  6.1 [Промышленный и тестовый стенды](#промышленный-и-тестовый-стенды) \
  6.2 Важность их сравнения \
  6.3 [Источники нагрузки](#источники-нагрузки) \
  6.4 [Смежные системы](#смежные-системы) \
  6.4 [Заглушки](#заглушки) \
  6.5 [Протоколы сетевые](#протоколы-сетевые) \
    6.5.1 [Стек (TCP/IP)](#стек-tcpip) \
    6.5.2 [НТТР. Состав запроса и ответа, основные методы, коды ответа](#http-состав-запроса-и-ответа-основные-методы-коды-ответа) \
    6.5.3 [Стандарты обмена REST и SOAP](#) \
  6.6 [Двухзвенная и трехзвенная архитектура](#двухзвенная-и-трехзвенная-архитектура) \
    6.6.1 [Толстый и тонкий клиенты](#толстый-и-тонкий-клиенты) \
    6.6.2 [Основные компоненты тестируемых систем](#основные-компоненты-тестируемых-систем) \
    6.6.3 [Микросервисная и монолитная архитектура](#микросервисная-и-монолитная-архитектура) \
    6.6.4 [Балансировщики нагрузки](#балансировщик-нагрузки) \
    6.6.5 [Брокеры сообщений](#брокеры-сообщений)
7. [JMeter](#jmeter) \
  7.1. [Разработка скриптов](#разработка-скриптов) \
    [Параметризация](#параметризация) \
    [Корреляция](#корреляция) \
    [Верификация](#верификация) \
    [Pacing](#pacing) \
  7.2 [Выполнение тестов](#) \
    Создание теста по профилю из МНТ \
    [Интеграция c InfluxDB+Grafana](#интеграция-c-influxdbgrafana) \
    Распределенный запуск теста \
  7.3 Разбор результатов тестов \
    Основные графики \
    Порядок разбора результатов \
  7.4 [Основные элементы](#основные-элементы)
8. [Обзор средств мониторинга](#обзор-средств-мониторинга)
9. [Метрики, собираемые во время нагрузочного тестирования (классификация и примеры наиболее важных)](#метрики-собираемые-во-время-нагрузочного-тестирования)
10. [Базы данных](#базы-данных) \
  10.1 [Введение в БД (классификация и примеры)](#введение-в-бд-классификация-и-примеры) \
  10.2 [Соответствие требованиям ACID](#соответствие-требованиям-acid) \
  10.3 [Терминология и нормальные формы](#терминология-и-нормальные-формы) \
  10.4 [SQL (DDL, DML, DCL, TCL)](#sql-ddl-dml-dcl-tcl)
  10.5 [Select, Update, Insert, Trancate, Delete](#select-update-insert-trancate-delete)
  10.6 [Индексы (плюсы и минусы)](#индексы-плюсы-и-минусы)
  10.7 [View vs Table](#view-vs-table)
  10.8 [Алиасы](#алиасы)
  10.9 [Oracle, AWR](#oracle-awr)
  10.10 [PostgreSQL, аналоги AWR](#postgresql-аналоги-awr)
  10.11 [План запроса (как построить и зачем)](#план-запроса-как-построить-и-зачем)
11. [Введение в заглушки](#)
    - Определение и назначение
    - Плюсы и минусы использования
    - Обзор инструментов и фрейворков
12. [Создание отчетов НТ](#)
13. [Основы программирования](#основы-программирования)
    - [Парадигмы ООП](#парадигмы-ооп)
    - [Классы и объекты](#классы-и-объекты)
14. [Garbage Collection и JVM](#garbage-collection-и-jvm)
15. [Самопредставление](#самопредставление)
    - [О себе](#о-себе)
    - [О выполненных в рамках школы работах](#о-выполненных-в-рамках-школы-работах)

## Основы тестирования

### Требования

__Требования__ — это конкретные условия и параметры, которым должен соответствовать программный продукт или система. Они определяют, что именно нужно протестировать, чтобы убедиться в качестве продукта.

Требования бывают:

- __Функциональные__ – описание, как система должна функционировать, ее поведение. Причём должно быть указаны реакции системы на те или иные входные данные, как она ведёт себя в определённых ситуациях и т.д.

- __Нефункциональные__ - описывают характеристики системы и её окружения, а не поведение системы. Нефункциональные требования не связаны непосредственно с функциями, выполняемыми системой. Они связаны с такими свойствами системы, как производительность, безопасность, удобство использования, возможность переноса на различные платформы, совместимость.

Тестирование требований позволяет проверить соответствие программного продукта установленным критериям и стандартам, а также выявить возможные проблемы и недочёты на ранних этапах разработки. Это помогает обеспечить высокое качество продукта и его успешное внедрение на рынок.

### Дефекты

__Дефект, баг__ - несовершенство или недостаток в рабочем продукте, если он не соответствует требованиям или спецификациям.

__Баг-репорт__ - это документ, описывающий ситуацию или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.

Существует несколько вариантов градации дефектов. Одним из ключевых - по степени влияния на функционал системы:

- S1 блокирующий (blocked)
- S2 критический (critical)
- S3 значительный (major)
- S4 незначительный (minor)
- S5 тривиальный (trivial)

По приоритеру:

- P1 высокий (high)
- P2 средний (medium)
- P3 низкий  (low)

### Виды тестирования

Тестирование программного обеспечения можно классифицировать по различным критериям.

![Классификация тестирования](/images/image_01.jpeg)

Основные виды тестирования:

__Функциональное__ — вид тестирования, при котором проверяются функциональные требования ПО, то есть способность ПО решать возложенные на него задачи. Направлено на проверку корректности работы функциональности приложения. Например, в приложении интернет‑магазина при нажатии на кнопку "Добавить в корзину", товар добавляется в корзину пользователя.

__Автоматизированое__ — тип тестирования, при котором проверки выполняются с использованием программных средств для выполнения тестовых сценариев.
Например, тестировщик пишет код на JavaScript для автоматизации процесса авторизации на сайте.

__Нагрузочное тестирование__ — это проверка системы на соответствие нефункциональным требованиям, таким как производительность, отказоустойчивость, стрессоустойчивость, масштабируемость, стабильности. Проверка устойчивости и производительности программного обеспечения под нагрузкой, сопоставимой с реальными условиями использования.

[Дополнительная информация](https://habr.com/ru/articles/770600/)

[Вопросы](#вопросы)

## Методика нагрузочного тестирования

Перед тем как приступить к проверке программного продукта, нужно разработать __методику нагрузочного тестирования (МНТ)__. Это документ, в котором описан весь план тестирования, включая сценарии возможного развития проекта. МНТ полезна как заказчикам, так и команде исполнителей, потому что позволяет формализовать требования, однозначно определить ожидания от проекта.

### Назначение, почему это важно

Для заказчика - фиксирование всех договоренностей с исполнителем, чтобы он понимал, что получит на выходе.
Для специалистов НТ - МНТ является некоторой "страховкой" при общении с заказчиком. Также МНТ - это инструкция, содержащая информацию по распределению работ. Помогает с передачей знаний по проекту.

### Основные разделы

Основные разделы методики нагрузочного тестирования:

Сокращения и терминология – общий список, встречающийся по тексту. \
Введение – общие слова о проведении НТ. \
__Цели тестирования__ – цели НТ, которые определяют виды тестов. \
__Ограничения и риски__ –  обязательно указываем существующие ограничения и возможные риски. Все влияет на результаты тестирования. \
Объект тестирования – данные раздела берутся из ТЗ на тестируемую систему. \
Стратегия тестирования. Набор тестов детализируется информацией о способе из провдедения. \
Тестовый стенд – схема с описанием тестового стенда, смежных систем, элементов для записи скриптов, моделирования нагрузки и мониторинга. Так же приводится сравнение тестового и промышленного стендов. \
Планируемые тесты – список панируемых тестов с детализацией способов их проведения. \
Моделирование нагрузки – инструменты НТ, профиль нагрузки, сценарии и заглушки. \
Наполнение БД. При необходимости указывается, до каких объемов необходимо наполнить БД. \
Мониторинг. Указывается перечень используемых средств мониторинга и список собираемых метрик. \
Требования к заказчику. В разделе приводятся требования к обеспечению процесса нагрузочного тестирования со стороны заказчика.

[Вопросы](#вопросы)

## Введение в методологию нагрузочного тестирования

__Нагрузка__ — это количество запросов или операций, которые выполняются на систему за определённый период времени. Нагрузка может быть постоянной или переменной, а также может изменяться в зависимости от времени суток, дня недели и других факторов.

Виды нагрузки:

- __Статическая нагрузка__ — заранее определённое количество запросов, которое выполняется на систему. Статическая нагрузка используется для проверки стабильности системы при определённой нагрузке.
- __Динамическая нагрузка__ — нагрузка, которая изменяется во время тестирования. Динамическая нагрузка позволяет проверить производительность системы при различных условиях.

__Производительность__ — это способность системы выполнять задачи за определённое время. Производительность измеряется в количестве запросов в секунду (QPS), времени отклика (response time) и других показателях.

__Деградация показателей__ — это ухудшение ключевых метрик производительности системы.

### Типовой план работ по нагрузочному тестированию

На следующем рисунке отображен полный цикл нагрузочного тестирования.

![Полный цикл нагрузочного тестирования](/images/image_01_1.png)

Ниже изображен процесс нагрузочного тестирования по релизам.

![Процесс нагрузочного тестирования по релизам](/images/image_01_2.png)

### Цели НТ

Основная цель __нагрузочного тестирования__ - проверка системы на соответствие нефункциональным требованиям.

Основными целямя являются:

- определение максимальной производительности;
- выявление "узких мест";
- проверка стабильности;
- проверка отказоустойчивости;
- проверка стрессоустойчивости;
- проверка системы при стрессовых ситуациях;
- оценка влияния мониторинга;
- проверка масштабирования;
- оценка влияния объемов;
- подборка оптимального комплекса технических средств (КТС);
- проверка исправления ошибок.

Каждую цель необходимо конкретизировать до технических требований. Критерии успеха.

### Виды нагрузочного тестирования

__Нагрузочное тестирование (Load Testing).__ Проверка соответствия системы нефункциональным требованиям.
Проверяет работоспособность системы или сайта при заданной нагрузке. С его помощью можно понять, сможет ли система за определенное время обработать желаемое количество запросов.

Существует довольно много видов НТ, при этом у каждого свои цели и специфика. Выбор конкретного вида зависит от требований к системе, а также планируемых условий ее использования:

__Поиск максимальной производительности.__ По результатам тестирования определяется максимальный уровень производительности, при котором система соответствует требованиям, предъявляемым к ней в части
производительности (по временам отклика, утилизации ресурсов, кол-во ошибок и т.д.).

__Тестирование стабильности (Stability Testing).__ Это проверка работоспособности и надежности системы на протяжении длительного времени.

__Стресс тест.__ Целью теста является проверка поведения системы при разных не прогнозируемых условиях. Условия данного теста обговариваются с заказчиком.

__Тестирование стрессоустойчивости (Stress Testing).__ Проводят, чтобы проверить работоспособность системы при огромных нагрузках — больших, чем ожидается в обычных условиях.

__Тестирование отказоустойчивости (Failover Testing).__ Проверка работоспособности системы при аварийных ситуациях. Например, чтобы узнать, переключилась ли система на резервный сервер, если сбой все-таки случился.

__Тестирование объемов (Volume Testing).__ Проверка стабильности системы при работе с большим объемом данных. Показывает, насколько меняется производительность при их обработке.

__Тестирование масштабируемости (Scalability Testing).__ Это тестирование стабильной работы системы при ожидаемом увеличении нагрузки, например, при большем количестве пользователей или объеме данных. Целью теста является проверка влияния увеличения ресурсов системы на её производительность.

### Поиск максимальной производительности

По результатам тестирования определяется максимальный уровень производительности, при котором система соответствует требованиям, предъявленным к ней в части произоводительности. Например, время отклика, утилизация ресурсов, количество ошибок и т.д.

Тест состоит из двух этапов:

- ступенчатый тест;
- подтверждение максимума.

На первом этапе. Нагрузка подается ступенчато. Определяется предельный уровень нагрузки __L0__. Также может быть определена __Lпик__. Предыдущая ступень от __L0__ – предполагаемый максимум __Lmax__.

__L0__ — уровень нагрузки, при котором нарушаются требования к системе за пределы допустимого SLA. \
__Lmax__ — уровень максимальной нагрузки, которую система может выдержать без деградации до критичный уровней SLA. \
__Lпик__ — уровень нагрузки, после которого происходит деградация системы (интенсивность успешно выполняемых операций не растет, либо падает).

![Ступенчатый тест](/images/image_02.png)

Высота ступени зависит от требуемой точности. Длина ступени должна быть достаточной для сбора необходимого количества метрик. Для ступени расчитывается по первой ступени (так как в этот момент наименьшая нагрузка) и зависит от pacing и нагрузки. Длина и высота ступеней на протяжении теста остается одинаковой.

__90-й персентиль__ — это значение, ниже которого находится 90% всех измеренных показателей при выполнении нагрузки.

На втором этапе. Нагрузка подается в течение чана на одном уровне предполагаемого __Lmax__, с плавным выходом на него. Во время теста не должно наблюдаться нарушение требований SLA (времен отклика, утечки памяти, утилизация ресурсов или других изменений).

![Подтветждение максимума](/images/image_03.png)

### Тестирование стабильности

По результатам тестирования определяется возможность системы работать длительное время под нагрузкой.
Основная цель - проверка отсутствия деградации при длительной нагрузке (рост времен отклика, утечка памяти, накопление очередей и т.д.). Нагрузка может подается примерно на уровне 80% от максимума или на планируемом уровне нагрузки.

![Тестирование стабильности](/images/image_04.png)

Временя проведения теста стабильности:

- посменно. Время теста равняется время смены плюс один час;
- 24/4 Выбирается от 24 до 72 часов.

### Стресс тест

Целью теста является проверка поведения системы при разных не прогнозируемых условиях. Условия данного теста обговариваются с заказчиком.

Возможные варианты тестов:

- Одновременный переход большого количества пользователей по определённым страницам или какие либо действия, расчёты, покупки и т.д.;
- Одновременная авторизация всех зарегистрированных пользователей в систему;
- Изменение времён отклика смежных систем (ускорение работы смежной системы или наоборот увеличение времени обработки запросов).

### Тестирование стрессоустойчивости

Проводится проверка способности системы к самовосстановлению после стрессовой нагрузки на нее. В частности, определяется, за какое время происходит это восстановление. Повышается нагрузка по всему профилю нагрузочного тестирования.

![Тестирование стрессоустойчивости](/images/image_05.png)

### Тестирование отказоустойчивости

Проводится оценка влияния сбоев смежных систем или одной из компонент системы на работоспособность тестируемой системы, проверка способности системы восстанавливаться после устранения сбоев в смежной системе (по результатам тестирования предоставляется перечень систем и интерфейсов, сбои в которых критически влияют на работоспособность объекта тестирования).

![Тестирование отказоустойчивости](/images/image_06.png)

### Объемное тестирование

Целью теста является проверка влияния увеличения обрабатываемого объёма данных на производительность системы.

Тест проводится в несколько этапов. Первым этапом является тестирование максимальной производительности на системе до изменений, на втором этапом проводится повторный идентичный тест, но уже после изменений.
Изменения бывают двух типов:

- увеличение объёма хранимых данных (в БД, в файловой системе и т.д)
- увеличение объёма отправляемой информации на сервер

В случае, если внесённые изменения не повлияли на производительность системы, тест прошёл успешно и система не деградирует с ростом объёмов данных.

### Тестирование масштабируемости

Целью теста является проверка влияния увеличения ресурсов системы на её производительность.
Существуют два вида масштабируемости системы: вертикальный и горизонтальный. При вертикальном масштабировании происходит увеличение аппаратных ресурсов системы. При горизонтальном масштабировании увеличивают количество серверов приложений или pod микросервисов.

Тест проводится в несколько этапов. На первом этапе проводится тест поиска максимума на системе в первой конфигурации. Затем проводится серия идентичных тестов на разных вариантах конфигурации. После проведения этих тестов производится сравнение результатов. Если производительность системы увеличивается пропорционально увеличению ресурсов, значит система масштабируема и тест прошёл успешно. Любая система масштабируема до определённого уровня. После достижения этого уровня, рост производительности идёт не пропорционально увеличению ресурсов.

__Вертикальное масштабирование (scale up)__ — это процесс увеличения производительности системы путём добавления ресурсов на существующем узле, например, увеличения объёма оперативной памяти, добавления процессоров или использования более мощного процессора. Это позволяет одному узлу обрабатывать больше запросов и улучшает его производительность.

__Горизонтальное масштабирование (scale out)__ — это процесс добавления дополнительных узлов (серверов) в систему для распределения нагрузки между ними. Это позволяет системе обрабатывать больше запросов за счёт увеличения количества обрабатывающих узлов, а не за счёт улучшения характеристик одного узла.

![Тестирование масштабируемости](/images/image_07.png)

## Service Level Agreement

__SLA (Service Level Agreement)__ в тестировании — это соглашение между заказчиком и исполнителем об уровне предоставления услуг, которое определяет параметры качества.

В контексте тестирования SLA устанавливает стандарты и ожидания относительно качества продукта или услуги, а также определяет критерии успешности тестирования. Это помогает обеспечить соответствие продукта требованиям заказчика и стандартам качества.

Основные аспекты SLA в тестировании включают:

Цели и задачи тестирования: определение основных целей и задач тестирования, которые должны быть достигнуты в рамках SLA.
Критерии успешности: установление критериев, по которым будет оцениваться успешность тестирования, таких как количество найденных дефектов, время выполнения тестов и т. д.
Сроки и этапы тестирования: определение сроков и этапов проведения тестирования, чтобы обеспечить своевременное выполнение работ.
Ответственность сторон: распределение ответственности между заказчиком и исполнителем за выполнение условий SLA.

Таким образом, SLA является важным инструментом для обеспечения качества и надёжности продукта или услуги.

В нагрузочном тестировании под SLA понимают требования предъявляемые к системе, что в свою очередь для нас является основными критериями успешности теста. В нагрузочном тестировании SLA могут быть наложены следующием параметры системы:

- время отклика;
- процент ошибок;
- утилизация аппаратных ресурсов;
- время восстаносления системы.

## Профиль нагрузочного тестирования

__Профиль__ – набор операций, выбранных для нагрузочного тестирования, и их интенсивность.

В профиль входят:

- Наиболее интенсивные операции
- Бизнес критичные операции
- Тяжелые операции (ресурсоемкие)

### Расчет профиля нагрузочного тестирования

Расчет может проводиться:

- на основе аналитики;
- на основе статистики.

Последовательность действий при расчете профиля на основе статистики:

- Выбор периода сбора статистики (обычно последний квартал)
- Анализ и отсеивание неподходящих часов
- Выбор часа пиковой нагрузки
- Выбор операций для включения в профиль
- Определение интенсивности операций профиля

### Точность профиля

__Точность профиля__ нагрузочного тестирования — это показатель, который отражает, насколько точно тестовые сценарии и параметры нагрузки соответствуют реальным условиям использования системы или приложения. Точность считается как отношение суммы интенсивностей выбранных операций к сумме интенсивностей всех операций выбранного часа. Точность должна быть менее 90% от суммы интенсивносте всех операция выбранного часа.

### Случай с несколькими профилями (например, дневной и ночной)

Дневной профиль используется для имитации типичной дневной нагрузки на систему. Он включает в себя сценарии, которые отражают действия пользователей в течение рабочего дня.

Ночной профиль используется для проверки системы в условиях низкой нагрузки. Он позволяет выявить проблемы, связанные с ночным временем, когда активность пользователей минимальна. Например, можно протестировать систему резервного копирования данных или обновления программного обеспечения.

## Анализ архитектуры систем

__Анализ архитектуры системы__ — это процесс изучения и оценки структуры, компонентов и взаимодействий между ними в рамках определённой системы. Он включает в себя оценку дизайна системы, её компонентов, их взаимосвязей и поведения.

Единственной и самой точной моделью является сам объект тестирования. Для построения тестовой модели используется абстракция. Чем точнее тестовая модель, тем точнее будут результаты тестирования. Тестовая модель может и должна уточняться по ходу тестирования и по мере поступления дополнительных данных.

### Промышленный и тестовый стенды

__Промышленный стенд__ представляет собой среду, которая имитирует реальные условия эксплуатации системы или продукта. Это позволяет разработчикам и инженерам тестировать и отлаживать систему в условиях, максимально приближенных к реальным. Промышленный стенд может включать в себя аппаратное и программное обеспечение, а также другие компоненты, которые используются в производственной среде.

__Тестовый стенд__ предназначен для тестирования и отладки новых функций, изменений в системе или исправления ошибок. Тестовый стенд обычно имеет более контролируемую среду, что позволяет разработчикам изолировать определённые аспекты системы и тщательно протестировать их.

Оба типа стендов играют важную роль в процессе разработки и эксплуатации систем. Они помогают обеспечить качество и надёжность продуктов, а также позволяют разработчикам быстро и эффективно вносить изменения и улучшения.

### Источники нагрузки

Источниками нагрузки могут выступать внешние системы, пользователи, другие компоненты и внутренние процессы. В тестовом контуре источники нагрузки заменяются на скрипты, запускаемые на генераторах нагрузки.

Источники нагрузки делятся на два типа:

- видимые (пользователи, внешние системы);
- невидимые (фоновые процессы).

### Смежные системы

В нагрузочном тестировании __смежные системы__ — это системы, которые взаимодействуют с основной системой, подвергающейся нагрузке. Они играют важную роль в обеспечении точности и достоверности результатов тестирования.

Смежные системы включают:

- Базы данных. Системы, используемые для хранения и обработки данных. Нагрузочное тестирование должно учитывать нагрузку на базы данных, чтобы оценить их производительность и стабильность.
- API и веб-сервисы. Программные интерфейсы, через которые происходит обмен данными между системами. Тестирование API и веб-сервисов помогает выявить узкие места и проблемы с производительностью.
- Очереди сообщений. Системы обмена сообщениями, такие как RabbitMQ или Kafka. Нагрузочное тестирование очередей сообщений позволяет оценить их способность обрабатывать большое количество сообщений.
- Системы кэширования. Системы хранения данных в оперативной памяти для ускорения доступа к ним. Тестирование систем кэширования помогает определить их эффективность и влияние на производительность основной системы.
- Другие системы интеграции. Любые другие системы, с которыми основная система обменивается данными. Это могут быть системы электронной почты, платёжные системы и т. д.

Смежные системы могут быть испльзованы при проведении тестов или заменены заглушками.

### Заглушки

__Заглушки__ в нагрузочном тестировании — это специальные программные компоненты, которые используются для имитации ответов от внешних систем во время тестирования. Они позволяют разработчикам и тестировщикам создавать тестовые сценарии без необходимости подключения к реальным внешним сервисам.

Необходимость в заглушках может возникнуть в следующих случаях:

- смежные системы являются потенциально узким местом с точки зрения производительности;
- смежные системы не доступны на тестовом стенде;
- смежные системы еще не разработаны или находятся в постоянной доработке;
- есть необходимость проверить тестируемую системы при различных временах отклика смежных систем.

Заглушки помогают ускорить процесс тестирования, так как они предоставляют заранее определённые ответы на запросы, что позволяет сосредоточиться на функциональности тестируемого приложения. Это особенно полезно при проведении нагрузочного тестирования, когда необходимо проверить работу системы под высокой нагрузкой.

Для написания заглушки необходимо знать:

- тела запроса;
- тело ответа;
- время отклика;
- производительность;
- протокол передачи данных.

Основные преимущества использования заглушек в нагрузочном тестировании:

- Изоляция тестируемой системы. Заглушки позволяют изолировать тестируемую систему от внешних зависимостей, что упрощает процесс тестирования и позволяет сосредоточиться на конкретных функциях.
- Ускорение тестирования. Заглушки предоставляют быстрые и предсказуемые ответы, что ускоряет процесс тестирования.
- Контроль над тестовыми данными. Заглушки позволяют контролировать тестовые данные, что обеспечивает стабильность и повторяемость тестов.
- Упрощение отладки. Заглушки могут помочь упростить отладку, предоставляя контролируемые ответы на запросы.

Однако использование заглушек также имеет некоторые недостатки:

- Сложность создания и поддержки. Создание и поддержка заглушек может быть сложным и трудоёмким процессом.
- Риск ошибок. Неправильно настроенные заглушки могут привести к ошибкам в тестах.
- Ограниченная функциональность. Заглушки не всегда могут полностью заменить реальные внешние сервисы, что может ограничить тестирование некоторых функций.

## JMeter

Apache JMeter — это инструмент для нагрузочного тестирования, который позволяет моделировать различные сценарии нагрузки на веб-приложения и другие сервисы. Он поддерживает как параметризацию, так и корреляцию, что делает его идеальным выбором для создания реалистичных тестов.

### Разработка скриптов

__Скрипт (от англ. «script»)__ — это набор команд или инструкций, которые используются для автоматизации определённых задач или процессов. Скрипты могут быть написаны на различных языках программирования и использоваться в разных областях, таких как веб-разработка, автоматизация тестирования, управление задачами и т. д.

В автоматизации тестирования скрипты помогают автоматизировать процесс тестирования программного обеспечения, выполняя повторяющиеся задачи и проверяя результаты.

#### Параметризация

__Параметризация__ — это процесс, при котором тестовые сценарии настраиваются с использованием различных входных данных или параметров для имитации реальных условий работы системы. Параметризация позволяет автоматизировать процесс тестирования, делая его более эффективным и менее подверженным ошибкам. Параметризация позволяет ибежать кэширования на стороне системы.

Для параметрицации в JMeter испльзуются: User Variable Defines,  JSR223 PreProcessor, JSR223 PostProcessor, JSR223 Sampler, CSV Data Set Config.

#### Корреляция

__Корреляция__ — это процесс, при котором в ходе тестирования получают значения динамических параметров из ответов и используются в дальнейшеи для создания последующих запросов. Корреляция используется для создания более реалистичных сценариев, отражающих взаимодействие между различными компонентами системы. Это особенно важно, когда тестируемое приложение зависит от динамически генерируемых данных, таких как сессии, токены или идентификаторы. Корреляция также называется динамической параметризацией данных.

Для корреляции в JMeter испльзуются: Boundary Extractor, CSS Selector Extractor, Regular Expression Extractor, JSR223 PostProcessor.

#### Верификация

__Верификация__ — это процесс проверки и подтверждения, что полученный ответ соответствует ожидаемому. Тестовые сценарии и инструменты соответствуют требованиям и целям тестирования. Это ключевой этап, который обеспечивает точность и надёжность результатов тестирования.

Для верификации в JMeter испльзуются: Response Assertion, JSR223 Assertion, JSON Assertion.

__Кэширование__ — это процесс сохранения часто используемых данных или результатов вычислений в быстродоступной памяти, называемой кэшем, для ускорения последующего доступа к этим данным.

__Куки (cookie)__ — это небольшие файлы с данными, которые веб-сайты сохраняют на устройстве пользователя (например, на компьютере или смартфоне) при посещении этих сайтов. Эти файлы содержат информацию, которая позволяет веб-сайту «запомнить» пользователя, например, его предпочтения, настройки, историю посещений и т. д.

### Pacing

__Pacing (шаг нагрузки)__ — интервал времени в течение которого гарантировано выполняется один проход сценария. Состоить из времени выполнения сценария и паузы до запуска следующего сценария. Pacing необходим для поддержании заданной интенсивности работы теста.

Шаг нагрузги $P$, если заранее известно количество пользователей, расчитывается по формуле:

$$P=\frac{3600}{(U/N)},$$

где $U$ — интенсивность; \
$N$ — количество виртуальных пользователей.

Исходя из данной формулы можно выразить количество пользователей $N$:

$$N=\frac{U}{3600} * P$$

Количество транзакций в секунду:

$$t_{ps}=\frac{U}{3600}$$

Если не известно количество пользователей, то шаг нагрузки $P$ вычисляется по формуле:

$$P=t_{ср} * 3$$

где $t_{ср}$ — средниие время выполнения скрипта без нагрузки.

Затем вычисляет количество пользователей $N$. Полученное значение округляется до целого числа в большую сторону и расчитывается итоговый шаг нагрузки $P$.

В JMeter настройка pacing выполсяется с помощью элемента __Constant Throughput Timer__, который используются для задания фиксированного шага нагрузки.

Больше информации о Constant Throughput Timer [тут](https://loadtestweb.wordpress.com/2017/08/23/pacing/).

#### Интеграция c InfluxDB+Grafana

Собственные возможности Jmeter для вывода и анализа результатов тестов, к сожалению, оставляют желать лучшего. К счастью, у нас есть внешние инструменты:

InfluxDB - очень простая в настройке база данных для хранения временных рядов. \
Grafana - инструмент для визуализации данных, дающий большие возможности для построения графиков, таблиц и диаграмм, а также наложения различных данных друг на друга и поиска корреляций.

Для отправки данных в InfluxDB у Jmeter есть встроенный плагин __Backend Listener__.

### Основные элементы

__Группа потоков (Thread Group)__ – основной рабочий элемент, в который записываются сценарии, добавляется различная логика и элементы управления, участвующие в тесте.

__Элементы конфигурации (Configuration Elements)__ позволяют задавать глобальные настройки для всего тестового плана, а также объявлять переменные, данные из которых впоследствии уже будут использованы сэмплерами.
К числу наиболее важных элементов относятся следующие:

- CSV Data Set Config;
- HTTP Request Defaults;
- User Defined Variables;
- HTTP Header Manager;
- JDBC Connection Configuration;
- HTTP Cache Manager;
- HTTP Cookie Manager;
- FTP Request Defaults;
- Counter.

__Сэмплеры (Samplers)__ используются для обращения Jmeter к серверу путем отправки запросов. К числу наиболее важных сэмплеров относятся:

- HTTP Request;
- FTP Request;
- SMTP Sampler;
- JDBC Request;
- Debug Sampler.

__Логический контроллер (Logic Controller)__ позволяет выстроить порядок обработки сэмплеров в тестовом плане. К числу наиболее важных логических контроллеров относятся:

- Loop Controller;
- Random Controller;
- Recording Controller;
- RunTime Controller;
- If Controller;
- While Controller;
- Simple Controller.

__Препроцессоры (Pre-Processor)__ – это элементы Jmeter, которые используются для выполнения действий до выполнения запросов сэмплера в тестовом сценарии. Препроцессоры могут использоваться для различных задач тестирования производительности, таких как выборка данных из базы данных, установка тайм-аута между выполнением сэмплера или перед генерацией тестовых данных.

Среди самых важных препроцессоров можно выделить следующие:

- BeanShell PreProcessor;
- JSR223 PreProcessor;
- JDBC PreProcessor.

__Пост-обработчики (Post-Processors)__ – элементы Jmeter, которые выполняются после завершения сэмплеров и используются, главным образом, для обработки данных ответа сервера и извлечения конкретного значения разметки для его последующего использования в тесте.

Далее перечислены наиболее часто используемые пост-обработчики:

- Boundary Extractor;
- BeanShell PostProcessor;
- JSR223 PostProcessor;
- JDBC PostProcessor;
- CSS Selector Extractor
- JSON Extractor;
- Xpath Extractor;
- Regular Expression Extractor;
- Debug PostProcessor.

_Boundary Extractor_ — это пост-процессор, который позволяет извлекать данные из ответа сервера на основе заданных начальных и конечных границ (маркеров). Он используется для извлечения определённых фрагментов данных из ответов HTTP-запросов, таких как текст, XML или JSON.

__Таймеры (Timers)__ - используется для имитации пользовательского ожидания в Jmeter. К числу наиболее важных таймеров относятся:

- Constant Timer;
- Uniform Random Timer;
- Gaussian Random Timer;
- JSR223 Timer;
- BeanShell Timer.

__Элемент подтверждения (Assertion)__ используются в качестве инструмента проверки (верификации) в Jmeter. К числу наиболее важных элементов подтверждения можно отнести следующие:

- Response Assertion;
- Size Assertion;
- Duration Assertion;
- JSR223 Assertion.

__Листенеры (listeners)__– элементы тестового плана, которые используются для просмотра и анализа информации, собранной JMeter во время прохождения теста, в табличной или графической форме. В них также собраны и сгруппированы различные метрики производительности, с помощью которых могут быть выявлены ограничители производительности системы. Одними из самых востребованных листенеров являются:

- View Results Tree;
- Aggregate Report;
- Aggregate Graph;
- Simple Data Writer;
- Summary Report.

__Transaction Controller__ — транзакция верхнего уровня для замера длительности работы всего сценария и пауз.

__Ultimate Thread Group__ — сторонний эдемент, для задания количества пользователей и длительности их работы, для запуска сценария.

__Module Controller__ — ссылка на сценарий в __Test Fragment__

### Протоколы сетевые

__Модель OSI (Open Systems Interconnection)__ — это эталонная модель, разработанная для описания функций телекоммуникационных или вычислительных систем, необходимых для сетевого взаимодействия. Она разделяет процесс сетевого взаимодействия на семь взаимосвязанных уровней. Каждый уровень выполняет специфические функции и взаимодействует с уровнями непосредственно выше и ниже.

[Дополнительная информация](https://habr.com/ru/articles/820419/)

![Сложно о простом. Модель OSI и TCP/IPы](/images/image_08.png)

__Физический уровень L1 (Physical Layer):__

Функции: определяет электрические, механические, процедурные и функциональные характеристики для активации, поддержания и деактивации физических соединений между конечными системами.

Примеры: кабели, разъемы, электрические напряжения, физические топологии сетей.

Необходимые для этого уровня понятия: RS-232, RJ45, V.34, 100BASE-TX, SDH, DSL, 802.11.

__Канальный уровень L2 (Data Link Layer):__

Функции: обеспечивает надежную передачу данных через физический канал. Включает задачи по обнаружению и исправлению ошибок, а также управление доступом к среде передачи.

Примеры: Ethernet, MAC-адреса, фреймы, коммутаторы.

Необходимые для этого уровня понятия: Ethernet, 802.11, MAC/LLC, VLAN, ATN, HDP, Fibre Channel, FrameReplay, HDLC, PPP, Q.921, Token Ring.

__Сетевой уровень L3 (Network Layer):__

Функции: отвечает за маршрутизацию пакетов данных между узлами сети. Обеспечивает логическую адресацию и определяет пути передачи данных через различные сети.

Примеры: IP-адресация, маршрутизаторы, IP-протокол.

Необходимые для этого уровня понятия: IP, ARP, IPsec, ICMP, IGMP, OSPF.

__Транспортный уровень L4 (Transport Layer):__

Функции: обеспечивает надежную передачу данных, контроль ошибок, сегментацию и повторную сборку данных. Гарантирует, что данные передаются без потерь и дубликатов.

Примеры: TCP (Transmission Control Protocol), UDP (User Datagram Protocol).

Необходимые для этого уровня понятия: TCP, UDP, SCTP, SSL, TLS.

__Сеансовый уровень L5 (Session Layer):__

Функции: управляет сеансами связи между приложениями. Обеспечивает установку, поддержание и завершение сеансов, а также синхронизацию и управление обменом данными.

Примеры: управление сеансами, контроль диалога.

Более подробней в этой статье.

Необходимые для этого уровня понятия: Session establishment in TCP, SIP, RTP, RPC-Named pipes.

__Представительный уровень L6 (Presentation Layer):__

Функции: отвечает за преобразование данных в формат, подходящий для приложения или сети. Включает задачи по шифрованию, дешифрованию, сжатию и преобразованию данных.

Примеры: шифрование, кодирование данных, преобразование форматов.

Необходимые для этого уровня понятия: HTML, DOC, JPEG, MP3, AVI, Sockets.

__Прикладной уровень L7 (Application Layer):__

Функции: обеспечивает доступ приложений к сетевым услугам. Реализует протоколы, которые поддерживают конечные пользовательские процессы и сетевые приложения.

Примеры: HTTP (HyperText Transfer Protocol), FTP (File Transfer Protocol), SMTP (Simple Mail Transfer Protocol).

Необходимые для этого уровня понятия: DNS, WWW, HTTP, P2P, EMAIL, POP, SMTP, TELNET, SSH, FTP, TFTP.

#### Стек (TCP/IP)

#### HTTP. Состав запроса и ответа, основные методы, коды ответа

__Hypertext Transfer Protocol, HTTP (протокол передачи гипертекста)__ — это протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

__Запрос (HTTP Request)__ — это сообщение, которое отправляется клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к какому-либо ресурсу. Основой запроса является HTTP-заголовок.

__Ответ (HTTP Response)__ — это сообщение, которые сервер отправляте в ответ на клиентский запрос.

Каждое HTTP-сообщение состоит из следующих частей, которые передаются в указанном порядке:

- __Стартовая строка (англ. Starting line)__ — определяет тип сообщения. Используется для описания версии используемого протокола и другой информации.
- __Заголовки (англ. Headers)__ — характеризуют тело сообщения, параметры передачи и прочие сведения; после каждой строки следует символ CRLF.
- __Пустая строка__ То есть строка, в которой ничего не предшествует CRLF, она обозначает конец полей заголовка.
- __Тело сообщения (англ. Message Body)__ — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Стартовая строка сообщения

Стартовые строки различаются для запроса и ответа.

Стартовая строка ответа сервера имеет следующий формат:

HTTP/Версия КодСостояния Пояснение

где:

- __Версия__ — пара разделённых точкой цифр, как в запросе;
- __Код состояния (англ. Status Code)__ — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;
- __Пояснение (англ. Reason Phrase)__ — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.

 Поля заголовка

Поля HTTP заголовка предоставляют необходимую информацию о запросе или ответе или об объекте, отправленном в теле сообщения. Существует четыре типа заголовков HTTP-сообщений:

- General (Общие заголовки): эти поля заголовка имеют общее применение как для сообщений запроса, так и для сообщений ответа.
- Request (Заголовки запроса): эти поля заголовка применимы только для сообщений запроса.
- Response (Заголовки ответа): эти поля заголовка применимы только для ответных сообщений.
- Entity (Заголовки сущности): эти поля заголовка определяют метаинформацию о теле объекта

Все вышеупомянутые заголовки следуют одному и тому же общему формату, и каждое поле заголовка состоит из имени, за которым следует двоеточие (:) и значение поля, как показано ниже:

имя-поля: [значение-поля]

Ниже приведены примеры различных полей заголовка:

```text
Host: suip.biz
User-Agent: Chrome
Accept: */*

Date: Tue, 03 Nov 2020 06:15:50 GMT`
Server: Apache/2.4.46 (Unix) PHP/7.4.12
Vary: Accept-Encoding
X-Powered-By: PHP/7.4.12
X-Frame-Options: SAMEORIGIN
Content-Type: text/html; charset=UTF-8
X-Varnish: 328517
Age: 0
Via: 1.1 varnish (Varnish/6.5)
Accept-Ranges: bytes
Connection: keep-alive
```

Тело сообщения

Часть сообщения, которое называется телом, является необязательной для HTTP-сообщения, но если она доступна, она используется для переноса тела объекта, связанного с запросом или ответом. Если тело объекта присутствует, то обычно строки заголовков Content-Type и Content-Length указывают природу тела сообщения.

Тело сообщения — это та часть, которая содержит фактические данные HTTP-запроса (сюда же относятся данные, передаваемые через веб-формы и выгружаемые файлы) и данные HTTP-ответа от сервера (включая HTML код, файлы, изображения и т. д.). Ниже приводится простое содержание тела сообщения (ответ):

```text
<html>
<body>
<h1>Hello, World!</h1>
</body>
</html>
```

Метод запроса

__Метод HTTP (англ. HTTP Method)__ — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.

__Идемпотентные вызовы__ — это операции или запросы, которые можно повторять многократно, не изменяя результат после первого выполнения. Другими словами, повторный идемпотентный вызов не приводит к новым изменениям состояния системы или данных, если они уже были успешно обработаны (GET, HEAD, PUT, DELETE, OPTIONS, TRACE).

__Неидемпотентные вызовы__ — это операции или запросы, при повторном выполнении которых результат может измениться или побочные эффекты могут отличаться от первоначального вызова (POST, PUT, DELETE, PATCH).

| Метод   | Описание |
|---------|----------|
| GET     |  Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: `GET /path/resource?param1=value1&param2=value2 HTTP/1.1` Согласно стандарту HTTP, запросы типа GET считаются идемпотентными |
| HEAD    | Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. |
| POST    |  Применяется для передачи пользовательских данных заданному ресурсу, в том числе выгрузки файлов на веб-сервер. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер. В отличие от метода GET, метод POST не считается идемпотентным, то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария). |
| PUT     | Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented). |
| DELETE  | Удаляет указанный ресурс. |
| CONNECT | Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси. |
| OPTIONS | Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях. |
| TRACE   | Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе. |
| PATCH   | Аналогично PUT, но применяется только к фрагменту ресурса. |

Ответы

После получения и интерпретации сообщения запроса сервер отвечает сообщением ответа HTTP, его структура:

- Строка состояния
- Ноль или более полей заголовка (общие заголовки, заголовки ответа и заголовки сущности), за которыми следует символ CRLF
- Пустая строка (т.е. строка, в которой ничего не предшествует CRLF), указывающая на конец полей заголовка
- Необязательно тело сообщения

Код состояния

Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.

В настоящее время выделено пять классов кодов состояния.

| Код | Класс           | Назначение |
|-----|-----------------|------------|
| 1xx | Информационный  | Информирование о процессе передачи. Носят исключительно информативный характер и никак не влияют на обработку запроса. |
| 2xx | Успех           | Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения. |
| 3xx | Перенаправление | Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI. |
| 4xx | Ошибка клиента  | Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя. |
| 5xx | Ошибка сервера  | Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю. |

### Двухзвенная и трехзвенная архитектура

__Двузвенная (двухуровневая) архитектура__ программного обеспечения состоит из двух основных компонентов: клиентского приложения и сервера. Клиентское приложение отвечает за пользовательский интерфейс и обработку данных на стороне пользователя, а сервер обеспечивает хранение данных и выполнение бизнес-логики.

__Трёхзвенная (трёхуровневая) архитектура__ представляет собой более сложную структуру, состоящую из трёх основных компонентов: клиента, сервера приложений и сервера баз данных. Клиент отвечает за пользовательский интерфейс, сервер приложений обрабатывает запросы от клиента и взаимодействует с сервером баз данных, который хранит данные и выполняет операции с ними.

### Толстый и тонкий клиенты

__Толстый клиент__ — это компьютер или программа, которая выполняет большую часть работы по обработке данных и имеет достаточно ресурсов для выполнения сложных задач. Толстые клиенты обычно имеют большой объём памяти, мощный процессор и могут работать с различными приложениями. Они также могут хранить данные локально и обрабатывать их без необходимости обращения к центральному серверу.

Примеры толстых клиентов: настольные приложения, такие как Microsoft Office или Adobe Photoshop,     игровые приставки, которые могут выполнять сложные вычисления и запускать игры без подключения к интернету.

__Тонкий клиент__ — это устройство или программа, которое выполняет ограниченные функции и зависит от центрального сервера для обработки данных. Тонкие клиенты обычно не имеют мощных процессоров или большого объёма памяти и полагаются на сервер для выполнения задач. Они могут быть простыми в использовании и не требовать сложных настроек.

Примеры тонких клиентов: веб-браузеры, терминалы для доступа к удалённым рабочим столам, некоторые мобильные приложения, которые используют облачные технологии для хранения данных и обработки запросов.

### Основные компоненты тестируемых систем

![Основные компоненты тестируемых систем](/images/image_09.png)

### Микросервисная и монолитная архитектура

__Монолитная архитектура__ — это подход к разработке программного обеспечения, при котором все компоненты приложения интегрированы в единый исполняемый файл или модуль. В такой архитектуре все функции и модули тесно связаны между собой и работают как единое целое. Это упрощает разработку, тестирование и развёртывание на начальных этапах, но может стать проблемой при масштабировании и внесении изменений в будущем.

__Микросервисная архитектура__ — это подход, при котором приложение разбивается на небольшие независимые сервисы, каждый из которых выполняет определённую функцию и может быть развёрнут и масштабирован отдельно от других. Микросервисы взаимодействуют друг с другом через чётко определённые API, что позволяет разработчикам работать над каждым сервисом независимо, а также упрощает внесение изменений и масштабирование отдельных компонентов приложения.

Монолиты полезно использовать на начальных этапах проектов, чтобы облегчить развертывание и не тратить слишком много умственных усилий на управление кодом. Когда монолитное приложение становится большим и сложным, возникают трудности с его масштабированием и непрерывным развертыванием, а обновление становится неудобным.

Монолитное приложение создается как единое и неделимое целое, тогда как в микросервисной архитектуре его разбивают на множество независимых модулей, каждый из которых вносит свой вклад в общее дело. Приложение создают как набор независимо развертываемых сервисов, которые являются децентрализованными и разрабатываются независимо друг от друга.

### Балансировщик нагрузки

__Балансировщик нагрузки__ – это устройство, которое находится между пользователем и группой серверов и действует как невидимый посредник, обеспечивая одинаковое использование всех серверов и ресурсов.
Балансировка нагрузки направляет и контролирует интернет-трафик между серверами приложений и их посетителями или клиентами. В результате повышается доступность, масштабируемость, безопасность и производительность приложения.

__Статическая балансировка нагрузки__
Алгоритмы статической балансировки нагрузки следуют фиксированным правилам и не зависят от текущего состояния сервера.

- Метод круговой системы
- Взвешенный циклический метод
- Метод хеширования IP

__Динамическая балансировка нагрузки__
Алгоритмы динамической балансировки нагрузки проверяют текущее состояние серверов перед распределением трафика.

- Метод наименьшего подключения
- Метод наименьшего количества подключений.
- Метод наименьшего времени отклика
- Метод на основе ресурсов

### Брокеры сообщений

__Брокер сообщений__ представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника.

В работе любого брокера сообщений используются две основные сущности: __producer (поставщик сообщений)__ и __consumer (потребитель/подписчик)__.
Одна сущность занимается созданием сообщений и отправкой их другой сущности-потребителю. В процессе отправки есть ещё серединная точка, которая представляет собой папку файловой системы, где хранятся сообщения, полученные от продюсера.
Брокеры сообщений реализуют механизм асинхронного обмена данными.

__RabbitMQ__ - представляет собой классический брокер, в котором присутствуют две сущности – продюсер (система, генерирующая сообщения о разнообразных событиях) и подписчик, являющийся получателем этих сообщений.
Обе эти сущности в процессе работы взаимодействуют с очередью сообщений, которая представляет собой хранилище, где накапливаются отправляемые сообщения.
В рамках этого брокера инициатором информационного обмена является продюсер, только он отправляет сообщение в сеть, в то время как подписчик не может запросить его сам («push-доставка сообщений»).

__Apache Kafka__ представляет собой брокер, который, в отличие от RabbitMQ, хранит все сообщения в виде распределённого лога, причём гарантируется, что порядок сообщений отражает последовательность их поступления в систему. Сообщение в этом логе хранится в течение определённого времени, и работа построена таким образом, что продюсеры пишут новые сообщения в систему, а подписчики сами их запрашивают. По сути Kafka представляет из себя log-транзакции.

### Обзор средств мониторинга

Prometheus+Grafana

__Prometheus__ — это система мониторинга и оповещения с открытым исходным кодом, предназначенная для сбора и хранения метрик в виде временных рядов. Она позволяет отслеживать различные показатели производительности и состояния систем, сервисов и приложений. Является сборщиком и хранилищеи данных.

__Grafana__ — это инструмент с открытым исходным кодом для мониторинга и анализа данных в реальном времени. Он предоставляет возможность создания интерактивных дашбордов, визуализации метрик и работы с различными источниками данных, такими как базы данных временных рядов, логи и другие. Является инструментом отрисовки данных.

Telegraf+InfluxDB+Grafana

__Telegraf__ — это агент для сбора метрик и событий, который собирает, структурирует и отправляет данные на серверы для дальнейшей обработки и анализа. Он может собирать данные из различных источников, таких как системы мониторинга, логи, базы данных и другие, и отправлять их в различные системы хранения данных, такие как InfluxDB, Graphite, Prometheus и другие. Является сборщиком данных.

__InfluxDB__ — это база данных типа «ключ-значение» с открытым исходным кодом, специально разработанная для работы с временными рядами данных. Она используется для хранения и анализа данных, которые меняются во времени, таких как метрики, логи, события и другие типы данных, генерируемых в реальном времени. Является хранилищем данных.

### Метрики, собираемые во время нагрузочного тестирования

__Метрики__ — это количественные показатели, которые используются для оценки производительности и стабильности системы при различных уровнях нагрузки. Они помогают определить, как система справляется с нагрузкой, и выявить потенциальные проблемы.

Во время нагрузочного тестирования мониторятся:

- Бизнес-метрики;
- Аппаратные метрики;
- Программные метрики.

#### Бизнес-метрики

__Бизнес-метрики__ — это показатели, которые помогают оценить, как система справляется с нагрузкой и насколько эффективно она работает в условиях реального использования. Они позволяют понять, насколько хорошо система соответствует бизнес-целям и требованиям пользователей.

К бизнес-метрикам относятся:

- __Интенсивность операций или пропускная способность (Throughput)__ — количество запросов, которые система может обработать за определённый период времени. Измеряется в запросах в секунду или транзакциях в минуту.
- __Время отклика (Response Time)__ — время, которое требуется системе для обработки запроса пользователя. Измеряется от момента отправки запроса до получения ответа.
- __Процент ошибок (Error Rate)__ — процент запросов, которые не были обработаны успешно. Помогает выявить проблемы с производительностью или стабильностью системы.
- __Количество виртуальных пользователей (Concurrent Users)__ — максимальное количество пользователей, которые могут одновременно работать с системой без потери производительности.

#### Аппаратные метрики

__Использование ресурсов (Resource Utilization)__ — показатели использования CPU, памяти, дискового пространства и других ресурсов системы при различных нагрузках.

К аппаратным метрикам относятся:

- Процессор (CPU);
- Оперативная память (RAM);
- Диск (disk);
- Сеть (NET).

Процессор (CPU):

- __Утилизация CPU (CPU utilization)__ — это показатель, который отражает степень использования процессорного времени.
- __Время простоя (idle time)__ — это время, в течение которого CPU не выполняет никаких задач.
- __Длина очереди к CPU (Processor Queue Length)__ — это количество задач, ожидающих обработки процессором.
- __Интенсивность контектсных переключений__ — это частота, с которой процессор переключается между различными задачами или потоками.

Оперативная память (memory):  

- Объем/процент свободной памяти
- Объем/частота использования файла подкачки (swap)

__Объём свободной памяти__ — это количество неиспользуемой в данный момент оперативной памяти. Он измеряется в байтах (чаще всего в гигабайтах). Чем больше свободной памяти, тем больше ресурсов доступно для запуска и работы программ.

__Процент свободной памяти__ — это отношение объёма свободной памяти к общему объёму оперативной памяти, выраженное в процентах. Этот показатель позволяет оценить, насколько эффективно используется оперативная память.

__Объём файла подкачки__ — это размер этого файла, который может быть задан пользователем или автоматически определён системой.

__Частота использования файла подкачки__ — это показатель того, как часто система обращается к файлу подкачки для обмена данными с оперативной памятью.

__Файл подкачки (swap file)__ — это специальный файл на жёстком диске или другом носителе, который используется операционной системой для временного хранения данных, когда объём оперативной памяти (RAM) компьютера заполнен.

Диск (disk):

- Скорость операций чтения/записи
- Длина очереди диска
- Свободное место на диске и/или в конкретных директориях

Сеть (NET):

- Скорость передачи данных
- Задержка сети
- Потеря пакетов
- Очередь пакетов

#### Программные метрики

- заглушки
- базы данных
- сервера приложений
- веб-серверы
- интешрационные решения

Если заглушка, написана на Java, то снимаются метрики:

- __Threads count__ – количество потоков;
- __Free memory__ – свободный объем кучи (heap);
- __GC__ – работа сборщика мусора ().

Если сервер приложения и веб-сервера, выполняющие код на Java. Основные метрики:

- __Threads count__ – количество потоков
- __Free memory__ – свободный объем heap
- __HTTP Requests__ – количество запросов
- __Sessions count__ – количество активных сессий

В случае микросервисной архитектуры:

- __Threads count__ – количество потоков
- __Free memory__ – свободный объем heap
- __HTTP Requests__ – количество запросов
- __Sessions count__ – количество активных сессий

Базы данных

Основные online-метрики:

- Количество сессий в различных статусах (active, inactive, wait…)
- Количество блокировок

На стороне App:
Количество connection pool

Основные offline-метрики:

- рейтинг запросов по времени ответа
- рейтинг запросов по утилизации ресурсов
- прочие, которые рассматриваются в теме про СУБД

Интеграционные решения (брокеры сообщений)

- длина очереди для Rabbit MQ по каждой очереди;
- Лаг для Kafka по каждой очереди.

[Вопросы](#вопросы)

### Базы данных

__База данных (БД)__ - совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных.

__Система управления базами данных (СУБД)__ - это комплекс программного обеспечения, предназначенный для создания, управления, хранения, манипуляции и извлечения данных в базах данных.

СУБД обеспечивает эффективный доступ к данным и их управление, предоставляя механизмы для безопасного хранения, организации и обработки информации. Работа с СУБД позволяет пользователям и приложениям использовать запросы для извлечения необходимых данных, а также обновлять и управлять данными без необходимости знать, где и как они физически хранятся.

Основные функции СУБД:

- __Хранение данных:__ СУБД предоставляют структурированное хранилище для больших объемов данных. Данные обычно хранятся в таблицах, которые состоят из строк и столбцов, и могут быть организованы в различных типах баз данных, таких как реляционные, нереляционные (NoSQL), объектные и другие.
- __Манипуляция данными:__ С помощью языков запросов, таких как SQL для реляционных СУБД, пользователи могут выполнять различные операции с данными, включая поиск, сортировку, фильтрацию, вставку, обновление и удаление.
- __Транзакционность:__ СУБД поддерживают концепцию транзакций, обеспечивающих консистентность и надежность данных даже в условиях многопользовательского доступа и возможных системных сбоев. Транзакции обладают свойствами ACID (Atomicity, Consistency, Isolation, Durability — атомарность, консистентность, изоляция, долговечность).
- __Многопользовательский доступ:__ Системы управления базами данных обеспечивают контролируемый доступ к данным для множества пользователей одновременно, соблюдая при этом права доступа и обеспечивая безопасность данных.
- __Безопасность:__ СУБД включают механизмы защиты данных, такие как аутентификация пользователей, шифрование данных и управление правами доступа к данным и функциям системы.
- __Резервное копирование и восстановление:__ СУБД предоставляют инструменты для создания резервных копий данных и их восстановления после сбоев или потерь данных, минимизируя риск потери важной информации.

#### Введение в БД (классификация и примеры)

Модели данных:

- Реляционная (MySQL, DB2, Postgres, MS Access)
- Промежуточные (Oracle – объектно-реляционная)
- Временных рядов (InfluxDB)
- NoSQL с гибкой моделью данных (Mongo, Ignite, Cassandra)
- Структурная (Redis)
- Документно-ориентированная (Elasticsearch)

Способ доступа:

- Файл-серверные (MS Access, Paradox, dBase)
- Клиент-серверные (Oracle, DB2, MSSQL, MySql, Postgres)
- Встраиваемые (SQLite, MSSQL Compact)

### Соответствие требованиям ACID

Для соблюдения целостности данных все транзакции в БД должны соответствовать требованиям ACID, то есть быть атомарными, согласованными, изолированными и надежными.

__Atomicity (атомарность)__ – выражается в том, что транзакция должна быть выполнена в целом или не выполнена вовсе. Это означает, что если какая-либо часть транзакции не может быть завершена, то все изменения, сделанные в рамках этой транзакции, будут отменены (откат).

__Consistency (согласованность)__ – обеспечивает сохранение целостности данных. После завершения транзакции база данных должна перейти из одного согласованного состояния в другое. Это означает, что данные должны соответствовать определённым правилам и ограничениям, таким как уникальные ключи, внешние ключи и т. д.

__Isolation (изолированность)__ — гарантирует, что параллельное выполнение транзакций не повлияет на результат каждой из них. То есть, транзакции выполняются так, как будто они выполняются по очереди, даже если на самом деле они выполняются параллельно.

__Durability (надежность)__ — обеспечивает сохранность данных после успешной транзакции. Это означает, что после подтверждения транзакции изменения данных сохраняются и не будут потеряны даже в случае сбоя системы.

#### Терминология и нормальные формы

__Реляционная база данных__ — это составленная по реляционной модели база данных, в которой данные, занесенные в таблицы, имеют изначально заданные отношения. Сами таблицы в такой базе данных также соотносятся друг с другом строго определенным образом. Реляционные базы данных используют целый комплекс инструментов, которые обеспечивают целостность данных, т. е. их точность, полноту и единообразие.

__Атрибут__ — свойство некоторой сущности. Часто называется полем таблицы. \
__Домен атрибута__ — множество допустимых значений, которые может принимать атрибут. \
__Кортеж__ — конечное множество взаимосвязанных допустимых значений атрибутов, которые вместе описывают некоторую сущность (строка таблицы). \
__Отношение__ — конечное множество кортежей (таблица). \
__Схема отношения__ — конечное множество атрибутов, определяющих некоторую сущность. Иными словами, это структура таблицы, состоящей из конкретного набора полей. \
__Проекция__ — отношение, полученное из заданного путём удаления и (или) перестановки некоторых атрибутов. \
Функциональная зависимость между атрибутами (множествами атрибутов) X и Y означает, что для любого допустимого набора кортежей в данном отношении: если два кортежа совпадают по значению X, то они совпадают по значению Y. Например, если значение атрибута «Название компании» — Canonical Ltd, то значением атрибута «Штаб-квартира» в таком кортеже всегда будет Millbank Tower, London, United Kingdom. Обозначение: {X} -> {Y}.

__Первичный ключ (Primary Key, PK)__ — это атрибут или набор атрибутов, который уникально идентифицирует запись в таблице базы данных. Он обеспечивает уникальность каждой записи и используется для быстрого доступа к данным. Первичный ключ не может принимать значение NULL и должен быть уникальным для каждой записи в таблице. \
__Внешний ключ (Foreign Key, FK)__ — это это атрибут или набор атрибутов в одной таблице, который ссылается на первичный ключ в другой таблице. Он используется для установления связи между таблицами и обеспечения целостности данных. Внешний ключ может принимать значение NULL, если это разрешено в его определении.

__Нормализация базы данных__ — это метод создания таблиц БД со столбцами и ключами путем разделения (или декомпозиции) таблицы большего размера на небольшие логические единицы. В данном методе учитываются требования, предъявляемые к среде БД.

__Нормализация__ — это итеративный процесс. Как правило, нормализация БД выполняется через серию тестов. Каждый последующий шаг разбивает таблицу на более легкую в управлении информацию, чем повышается общая логичность системы и простота работы с ней.

Нормализация базы данных выполняется с помощью набора правил. Такие правила называются нормальными формами. Основная цель данных правил - помочь разработчику БД в достижении нужного качества реляционной базы.
Все уровни нормализации считаются кумулятивными, или накопительными. Прежде чем перейти к следующему этапу, выполняются все требования к текущей форме.

| Стадия | Аномалии избыточности |
|---------|----------|
| Ненормализованная (нулевая) форма (UNF) | Это состояние перед любой нормализацией. В таблице присутствуют избыточные и сложные значения. |
| Первая нормальная форма (1NF) | Разбиваются повторяющиеся и сложные значения. Все экземпляры становятся атомарными |
| Вторая нормальная форма (2NF) | Частичные зависимости разделяются на новые таблицы. Все строки функционально зависимы от первичного ключа |
| Третья нормальная форма (3NF) | Транзитивные зависимости разбиваются на новые таблицы. Не ключевые атрибуты зависят от первичного ключа |
| Нормальная форма Бойса-Кода (BCNF) | Транзитивные и частичные функциональные зависимости для всех потенциальных ключей разбиваются на новые таблицы |
| Четвертая нормальная форма (4NF) | Удаляются многозначные зависимости |
| Пятая нормальная форма (5NF) | Удаляются JOIN-зависимости (зависимости соединения) |

#### SQL (DDL, DML, DCL, TCL)

Для взаимодействия с любой реляционной базой данных используется __SQL (Structured Query Language)__ — язык структурированных запросов. Это основа интерфейса систем управления базами данных. Он стандартизирован с 1986 года и поддерживается всеми известными ядрами реляционных баз данных. SQL позволяет работать со строками таблиц (например, удалять, добавлять или изменять их), а также извлекать нужные блоки информации и производить транзакции.

__DDL (Data Defenition Language)__ — это язык определения данных, который используется для создания, изменения и удаления структуры базы данных, например, таблиц, индексов и схем.

Примеры:

- `CREATE` - создает объекты базы данных (таблицы, представления и т.д.)
- `ALTER` - Изменяет структуру и объекты базы данных
- `DROP` - Удаляет объекты базы данных
- `TRUNCATE` - Удаляет все записи из таблицы
- `COMMENT` - Добавляет комментарии в словарь данных
- `RENAME` - Переименовывает объект (alter table <old_name> rename to <new_name>)

__DML (Data Manipulation Language)__ — это язык манипулирования данными, который используется для добавления, изменения, удаления и извлечения данных из базы данных.

Примеры:

- `SELECT` - Возвращает данные из базы данных.
- `INSERT` - Вставляет данные в таблицу.
- `UPDATE` - Обновляет существующие данные в таблице.
- `DELETE` - Удаляет одну или более строк в таблице.
- `MERGE` - UPSERT операция (insert или update).
- `CALL` - вызов подпрограммы PL/SQL или Java.
- `EXPLAIN PLAN` - Предоставляет план запроса.
- `LOCK TABLE` - Управление параллелизмом.

__DCL (Data Control Language)__ — это язык управления данными, который используется для предоставления или отзыва разрешений и прав доступа к базе данных и её объектам.

Примеры:

- `GRANT` - Дает пользователю права доступа к базе данных и ее объектам
- `REVOKE` - Забирает у пользователя права выданные командой GRANT

__TCL (Transaction Control Language)__ — это язык управления транзакциями, который используется для управления транзакциями в базе данных, обеспечивая их целостность и надёжность.

Примеры:

- `COMMIT` - Сохраняет изменения
- `SAVEPOINT` - Определяет точку транзакции до которой потом можно откатиться
- `ROLLBACK` - Восстанавливает базу данных на момент последней операции COMMIT. Откатывает транзакцию
- `SET TRANSACTION` - Изменяет опции транзакции, такие как: уровень изоляции и какой сегмент отката использовать

#### Select, Update, Insert, Trancate, Delete

#### Индексы (плюсы и минусы)

__Индексирование__ — это метод оптимизации базы данных, при котором создается дополнительная структура базы данных, называемая индексом, для хранения ссылок на записи в таблице.
Индекс обеспечивает ускоренный поиск данных, сокращая время выполнения запроса.
Однако индексы ЗАМЕДЛЯЮТ работу insert/update из-за необходимости перестройки индексов.
Также индексы занимают дополнительное место на диске и в памяти.

#### View vs Table

#### Алиасы

Можно временно переименовать таблицу или столбец, давая другое имя, известное как alias (псевдоним). \
Основное назначение алиасов - устранение неоднозначности при наличии одноимённых таблиц/полей. \
Дополнительно - удобство именования, особенно когда оригинальные имена длинные.

#### Oracle, AWR

#### PostgreSQL, аналоги AWR

#### План запроса (как построить и зачем)

SET SHOWPLAN_ALL ON – текстовое представление плана запроса \
SET SHOWPLAN_XML ON – графическое представление плана запроса (для SSMS) \
С помощью плана выполнения запроса можно узнать, как именно выполняется SQL запрос, т.е. какие именно операции совершаются, и вся эта информация нужна для того, чтобы в случае необходимости тем или иным образом повлиять на выполнение этого запроса.

### Основы программирования

#### Парадигмы ООП

__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

- объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
- каждый объект является экземпляром определенного класса;
- классы образуют иерархии.

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.

Оосновные принципы _ООП_:

- _Инкапсуляция_ - сокрытие реализации
- _Наследование_ - создание новой сущности на базе уже существующей
- _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности
- _Абстракция_ - набор общих характеристик
  
__Инкапсуляция__ – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется _предком_, _базовым_ или _родительским_. Новый класс – _потомком_, _наследником_ или _производным_ классом.

__Полиморфизм__ – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

Полиморфизм бывает _динамическим_ (переопределение) и _статическим_ (перегрузка).

_Полиморфная переменная_, это переменная, которая может принимать значения разных типов, а _полиморфная функция_, это функция у которой хотя бы один аргумент является полиморфной переменной.
Выделяют два вида полиморфных функций:

- _ad hoc_, функция ведет себя по разному для разных типов аргументов (например, функция `draw()` — рисует по разному фигуры разных типов);
- _параметрический_, функция ведет себя одинаково для аргументов разных типов (например, функция `add()` — одинаково кладет в контейнер элементы разных типов).

_Абстрагирование_ – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, __абстракция__ – это набор всех таких характеристик.

#### Классы и объекты

Класс — это тип данных, созданный пользователем. Он содержит разные свойства и методы, как, например, тип String или Integer. Класс — это «шаблон» для объекта, который описывает его свойства. Несколько похожих между собой объектов, например профили разных пользователей, будут иметь одинаковую структуру, а значит, принадлежать к одному классу.

Объект — это основная единица в ООП, представляющая собой экземпляр класса, сочетающий в себе данные (состояние) и методы (поведение) для работы с этими данными. Например, когда вы создаёте переменную типа String и присваиваете ей значение «Строка», то в памяти создаётся экземпляр класса String.

[Вопросы](#вопросы)

## Garbage Collection и JVM

__JVM, Java Virtual Machine (Виртуальная машина Java)__ — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

__JRE, Java Runtime Environment (Среда времени выполнения Java)__ — минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

__JDK, Java Development Kit (Комплект разработки на Java)__ — JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

В Java память разделена на несколько областей, каждая из которых служит определённой цели. Основные области памяти в Java включают:

__Heap (куча)__ — это область памяти, где хранятся объекты и массивы, созданные во время выполнения программы. Куча доступна для всех потоков в приложении.

__Stack (стек)__ — используется для хранения локальных переменных и ссылок на объекты в куче. Стек работает по принципу LIFO (Last In, First Out). Каждый поток имеет свой собственный стек.

__Method Area (область методов)__ — хранит информацию о классах, статические переменные и константы. Эта область также известна как «постоянное поколение» (PermGen) в старых версиях JVM, но в более новых версиях она была заменена на «метапространство» (Metaspace).

__PC Register (регистр программного счётчика)__ — хранит адрес следующей инструкции, которая должна быть выполнена для каждого потока.

__Native Method Stack (стек собственных методов)__ — используется для поддержки собственных методов (методов, написанных на других языках программирования, таких как C или C++), которые могут быть вызваны из Java-кода.

![JVM Native memory](/images/image_10.png)

Дополнительная информация по GC:

[Дюк, вынеси мусор! — 1. Введение](https://habr.com/ru/articles/269621/) \
[Дюк, вынеси мусор! — 2. Serial GC и Parallel GC](https://habr.com/ru/articles/269707/) \
[Дюк, вынеси мусор! — 3. CMS и G1](https://habr.com/ru/articles/269863/)

## Самопредставление

### О себе

### О выполненных в рамках школы работах

С помощью интстумента нагрузочного тестирования Apache JMeter выполнил серию тестов, таких как поиск максимальной прозводительности и тест стабильности, на учебноим приложении системы бронирования WebTours.

Выполнял следующие работы:

1. При помощи встроенных инструментов браузера освоил сохранение в har файл лога сетевых запросов браузера.
2. Научился конвертировать har файл в jmx формат онлайн конвертером от BlazeMeter <https://converter.blazemeter.com/>.
3. Научился использовать следующие элементы в JMeter:

- для параметрицации и корреляции: User Variable Defines,  JSR223 PreProcessor, JSR223 PostProcessor, JSR223 Sampler, CSV Data Set Config, Boundary Extractor, CSS Selector Extractor
- для реалистичности сценария испjльзовались: Thread Group, Constant Timer, HTTP Cache Manager, HTTP Cookie Manager, Module controller, Flow Control Actoin, Constant Throughput Timer;
- для верификации Response Assertion;
- для отладки и просмотра статистики: Debug Sampler, View Results Tree, Summary Report, Backand Listner.

Расчитал профиль нагрузки
Разработал и написал скрипты (JMeter)
Провел нагрузочного тестирования (тест максимальной производительности, тест стабильности)
Анализировал результаты тестирования (Grafana, InfluxDB, Telegraf)
Cоставил отчет о нагрузочном тестировании

Выводы и впечатления:

- Для себя открыл новое направленеие в разработке ПО - нагрузочное тестирование.
- Хорошая подача материала, последовательность. За теорией идет практика. Нагрузка и интенсивность повышаются постепенно. Мариал сделан таким образом, чтобы ученику пришлось подумать как выполнять задачи.
- В курсе отсутствует работа в команде как таковая. Но может на текущем этапе это и не требуется. Слишком мало времени.

Поблагодарить за опыт в области нагрузочного тестирования.
